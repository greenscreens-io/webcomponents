{"version":3,"file":"vanilla-lit-all.min.js","sources":["../modules/html/symbols.mjs","../modules/html/types.mjs","../modules/html/shared.mjs","../modules/html/dynamic/sanitizer.mjs","../modules/html/dynamic/parts/BasePart.mjs","../modules/html/dynamic/parts/attribute/AttributePart.mjs","../modules/html/dynamic/parts/attribute/BooleanAttributePart.mjs","../modules/html/dynamic/parts/attribute/EventPart.mjs","../modules/html/dynamic/parts/attribute/PropertyPart.mjs","../modules/html/dynamic/template/TemplateRenderer.mjs","../modules/html/dynamic/template/Template.mjs","../modules/html/dynamic/parts/element/ChildPart.mjs","../modules/html/dynamic/parts/element/ElementPart.mjs","../modules/html/dynamic/template/TemplateInstance.mjs","../modules/html/dynamic/dynamic.mjs","../modules/html/static.mjs","../modules/html/directive/directive-helpers.mjs","../modules/html/directive/directive.mjs","../modules/html/directive/async-directive.mjs","../modules/html/directive/directives/private-async-helpers.mjs","../modules/html/directive/directives/async-replace.mjs","../modules/html/directive/directives/async-append.mjs","../modules/html/directive/directives/cache.mjs","../modules/html/directive/directives/choose.mjs","../modules/html/directive/directives/class-map.mjs","../modules/html/directive/directives/guard.mjs","../modules/html/directive/directives/if-defined.mjs","../modules/html/directive/directives/join.mjs","../modules/html/directive/directives/keyed.mjs","../modules/html/directive/directives/live.mjs","../modules/html/directive/directives/map.mjs","../modules/html/directive/directives/range.mjs","../modules/html/directive/directives/ref.mjs","../modules/html/directive/directives/repeat.mjs","../modules/html/directive/directives/style-map.mjs","../modules/html/directive/directives/template-content.mjs","../modules/html/directive/directives/unsafe-html.mjs","../modules/html/directive/directives/unsafe-svg.mjs","../modules/html/directive/directives/until.mjs","../modules/html/directive/directives/when.mjs","../modules/core/AttributeConverter.mjs","../modules/core/ReactiveController.mjs","../modules/core/ReactiveControllerHost.mjs","../modules/core/css/shared.mjs","../modules/core/css/CSSResult.mjs","../modules/core/css/CSS.mjs","../modules/core/ReactiveElement.mjs","../modules/context/ValueNotifier.mjs","../modules/context/events/ContextRequestEvent.mjs","../modules/context/ContextRoot.mjs","../modules/context/controllers/ContextConsumer.mjs","../modules/context/events/ContextProviderEvent.mjs","../modules/context/controllers/ContextProvider.mjs","../modules/task/deep-equals.mjs","../modules/task/shallow-equals.mjs","../modules/task/task.mjs","../modules/ReactiveComponent.mjs"],"sourcesContent":["\r\nexport const partSymbol = Symbol('_$litPart$');\r\nexport const typeSymbol = Symbol('_$litType$');\r\nexport const directiveSymbol = Symbol('_$litDirective$');\r\nexport const notifySymbol = Symbol('_$notifyDirectiveConnectionChanged');\r\n\r\n/**\r\n * A sentinel value that signals that a value was handled by a directive and\r\n * should not be written to the DOM.\r\n */\r\nexport const noChange = Symbol.for('vlit-noChange');\r\n\r\n/**\r\n * A sentinel value that signals a ChildPart to fully clear its content.\r\n *\r\n * ```ts\r\n * const button = html`${\r\n *  user.isAdmin\r\n *    ? html`<button>DELETE</button>`\r\n *    : nothing\r\n * }`;\r\n * ```\r\n *\r\n * Prefer using `nothing` over other falsy values as it provides a consistent\r\n * behavior between various expression binding contexts.\r\n *\r\n * In child expressions, `undefined`, `null`, `''`, and `nothing` all behave the\r\n * same and render no nodes. In attribute expressions, `nothing` _removes_ the\r\n * attribute, while `undefined` and `null` will render an empty string. In\r\n * property expressions `nothing` becomes `undefined`.\r\n */\r\nexport const nothing = Symbol.for('vlit-nothing');","\r\n// TemplatePart types\r\n// IMPORTANT: these must match the values in PartType\r\nexport const PartType = {\r\n    ATTRIBUTE : 1,\r\n    CHILD : 2,\r\n    PROPERTY : 3,\r\n    BOOLEAN : 4,\r\n    EVENT : 5,\r\n    ELEMENT : 6,\r\n    COMMENT : 7\r\n}\r\nObject.seal(PartType);\r\n\r\nexport const ResultType = {\r\n    HTML : 1,\r\n    SVG : 2\r\n}\r\nObject.seal(ResultType);\r\n\r\n\r\n\r\n","\r\n// Added to an attribute name to mark the attribute as bound so we can find\r\n// it easily.\r\nexport const boundAttributeSuffix = '$vlit$';\r\nexport const marker = `vlit$${String(Math.random()).slice(9)}$`;\r\n\r\n// String used to tell if a comment is a marker comment\r\nexport const markerMatch = '?' + marker;\r\n\r\n// Text used to insert a comment marker node. We use processing instruction\r\n// syntax because it's slightly smaller, but parses as a comment node.\r\nexport const nodeMarker = `<${markerMatch}>`;\r\n\r\n// Creates a dynamic marker. We never have to search for these in the DOM.\r\nexport const createMarker = () => document.createComment('');\r\nexport const isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\r\nexport const isArray = Array.isArray;\r\nexport const isIterable = (value) => isArray(value) || typeof value?.[Symbol.iterator] === 'function';\r\n\r\n\r\nexport const walker = document.createTreeWalker(document, 129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */);\r\n","\r\nexport const ENABLE_EXTRA_SECURITY_HOOKS = true;\r\nconst trustedTypes = globalThis.trustedTypes;\r\n\r\n/**\r\n * Our TrustedTypePolicy for HTML which is declared using the html template\r\n * tag function.\r\n *\r\n * That HTML is a developer-authored constant, and is parsed with innerHTML\r\n * before any untrusted expressions have been mixed in. Therefor it is\r\n * considered safe by construction.\r\n */\r\nconst policy = trustedTypes\r\n    ? trustedTypes.createPolicy('vanilla-lite-dynamic', {\r\n        createHTML: (s) => s,\r\n    })\r\n    : undefined;\r\n\r\nconst identityFunction = (value) => value;\r\n\r\nconst noopSanitizer = (_node, _name, _type) => identityFunction;\r\n\r\nlet sanitizerFactoryInternal = noopSanitizer;\r\n\r\n/** Sets the global sanitizer factory. */\r\nexport const setSanitizer = (newSanitizer) => {\r\n    if (!ENABLE_EXTRA_SECURITY_HOOKS) return;\r\n    if (sanitizerFactoryInternal !== noopSanitizer) {\r\n        throw new Error(`Attempted to overwrite existing dynamic security policy.` +\r\n            ` setSanitizeDOMValueFactory should be called at most once.`);\r\n    }\r\n    sanitizerFactoryInternal = newSanitizer;\r\n}\r\n\r\nexport const isNoOp = sanitizerFactoryInternal === noopSanitizer;\r\n\r\nexport const sanityze  = sanitizerFactoryInternal;\r\n\r\nexport const createSanitizer = (node, name, type) => {\r\n    return sanitizerFactoryInternal(node, name, type);\r\n}\r\n\r\nexport const trustFromTemplateString = (tsa, stringFromTSA) => {\r\n    \r\n    // A security check to prevent spoofing of Lit template results.\r\n    // In the future, we may be able to replace this with Array.isTemplateObject,\r\n    // though we might need to make that check inside of the html and svg\r\n    // functions, because precompiled templates don't come in as\r\n    // TemplateStringArray objects.\r\n    if (!Array.isArray(tsa) || !Object.hasOwn(tsa, 'raw')) {\r\n        throw new Error('invalid template strings array');\r\n    }\r\n\r\n    return policy !== undefined\r\n        ? policy.createHTML(stringFromTSA)\r\n        : stringFromTSA;\r\n}\r\n","import { noChange, notifySymbol, directiveSymbol } from '../../symbols.mjs';\r\nimport { isPrimitive } from '../../shared.mjs';\r\n\r\nexport class BasePart {\r\n\r\n    resolveDirective(part, value, parent = part, attributeIndex) {\r\n    \r\n        if (value === noChange) return value;\r\n    \r\n        let currentDirective = attributeIndex !== undefined\r\n            ? parent.__directives?.[attributeIndex]\r\n            : parent.__directive;\r\n        \r\n        const nextDirectiveConstructor = isPrimitive(value)\r\n            ? undefined\r\n            : value[directiveSymbol];\r\n    \r\n        if (currentDirective?.constructor !== nextDirectiveConstructor) {\r\n            // This property needs to remain unminified.\r\n            currentDirective?.[notifySymbol]?.(false);\r\n    \r\n            if (nextDirectiveConstructor === undefined) {\r\n                currentDirective = undefined;\r\n            } else {\r\n                currentDirective = new nextDirectiveConstructor(part);\r\n                currentDirective._$initialize(part, parent, attributeIndex);\r\n            }\r\n    \r\n            if (attributeIndex !== undefined) {\r\n                (parent.__directives ??= [])[attributeIndex] = currentDirective;\r\n            } else {\r\n                parent.__directive = currentDirective;\r\n            }\r\n        }\r\n    \r\n        if (currentDirective !== undefined) {\r\n            value = this.resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);\r\n        }\r\n    \r\n        return value;\r\n    }\r\n\r\n}","import { PartType } from '../../../types.mjs';\r\nimport { isPrimitive } from '../../../shared.mjs';\r\nimport { nothing, noChange } from '../../../symbols.mjs'\r\nimport { ENABLE_EXTRA_SECURITY_HOOKS, sanityze } from '../../sanitizer.mjs';\r\n\r\nimport { BasePart } from '../BasePart.mjs';\r\n\r\nexport class AttributePart extends BasePart {\r\n\r\n    get tagName() {\r\n        return this.element.tagName;\r\n    }\r\n\r\n    // See comment in Disconnectable interface for why this is a getter\r\n    get _$isConnected() {\r\n        return this._$parent._$isConnected;\r\n    }\r\n\r\n    constructor(element, name, strings, parent, options) {\r\n        super(element, name, strings, parent, options);\r\n        this.type = PartType.ATTRIBUTE;\r\n        /** @internal */\r\n        this._$committedValue = nothing;\r\n        /** @internal */\r\n        this._$disconnectableChildren = undefined;\r\n        this.element = element;\r\n        this.name = name;\r\n        this._$parent = parent;\r\n        this.options = options;\r\n\r\n        if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\r\n            this._$committedValue = new Array(strings.length - 1).fill(new String());\r\n            this.strings = strings;\r\n        } else {\r\n            this._$committedValue = nothing;\r\n        }\r\n\r\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n            this._sanitizer = undefined;\r\n        }\r\n    }\r\n\r\n    _$setValue(value, directiveParent = this, valueIndex, noCommit) {\r\n\r\n        const strings = this.strings;\r\n\r\n        // Whether any of the values has changed, for dirty-checking\r\n        let change = false;\r\n        if (strings === undefined) {\r\n            // Single-value binding case\r\n            value = this.resolveDirective(this, value, directiveParent, 0);\r\n            change = !isPrimitive(value) || (value !== this._$committedValue && value !== noChange);\r\n            if (change) this._$committedValue = value;\r\n        } else {\r\n            // Interpolation case\r\n            const values = value;\r\n            value = strings[0];\r\n            let i, v;\r\n            for (i = 0; i < strings.length - 1; i++) {\r\n                v = this.resolveDirective(this, values[valueIndex + i], directiveParent, i);\r\n                // If the user-provided value is `noChange`, use the previous value\r\n                if (v === noChange) v = this._$committedValue[i];\r\n                change ||= !isPrimitive(v) || v !== this._$committedValue[i];\r\n                if (v === nothing) {\r\n                    value = nothing;\r\n                } else if (value !== nothing) {\r\n                    value += (v ?? '') + strings[i + 1];\r\n                }\r\n                // We always record each value, even if one is `nothing`, for future\r\n                // change detection.\r\n                this._$committedValue[i] = v;\r\n            }\r\n        }\r\n\r\n        if (change && !noCommit) {\r\n            this._commitValue(value);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    _commitValue(value) {\r\n        if (value === nothing) {\r\n            this.element.removeAttribute(this.name);\r\n        } else {\r\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n                if (this._sanitizer === undefined) {\r\n                    this._sanitizer = sanityze(this.element, this.name, 'attribute');\r\n                }\r\n                value = this._sanitizer(value ?? '');\r\n            }\r\n            this.element.setAttribute(this.name, (value ?? ''));\r\n        }\r\n    }\r\n}\r\n","import { PartType } from '../../../types.mjs';\r\nimport { nothing } from '../../../symbols.mjs'\r\nimport { AttributePart } from './AttributePart.mjs';\r\n\r\nexport class BooleanAttributePart extends AttributePart {\r\n\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = PartType.BOOLEAN;\r\n    }\r\n\r\n    /** @internal */\r\n    _commitValue(value) {\r\n        this.element.toggleAttribute(this.name, !!value && value !== nothing);\r\n    }\r\n}","import { nothing, noChange } from '../../../symbols.mjs'\r\nimport { PartType } from '../../../types.mjs';\r\nimport { AttributePart } from './AttributePart.mjs';\r\n\r\nexport class EventPart extends AttributePart {\r\n\r\n    constructor(element, name, strings, parent, options) {\r\n        super(element, name, strings, parent, options);\r\n        this.type = PartType.EVENT;\r\n    }\r\n\r\n    _$setValue(newListener, directiveParent = this) {\r\n\r\n        newListener = this.resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\r\n        if (newListener === noChange) return;\r\n        \r\n        const oldListener = this._$committedValue;\r\n\r\n        // If the new value is nothing or any options change we have to remove the\r\n        // part as a listener.\r\n        const shouldRemoveListener = (newListener === nothing && oldListener !== nothing) ||\r\n            newListener.capture !==\r\n            oldListener.capture ||\r\n            newListener.once !==\r\n            oldListener.once ||\r\n            newListener.passive !==\r\n            oldListener.passive;\r\n\r\n            // If the new value is not nothing and we removed the listener, we have\r\n        // to add the part as a listener.\r\n        const shouldAddListener = newListener !== nothing &&\r\n            (oldListener === nothing || shouldRemoveListener);\r\n        \r\n            if (shouldRemoveListener) {\r\n            this.element.removeEventListener(this.name, this, oldListener);\r\n        }\r\n        \r\n        if (shouldAddListener) {\r\n            // Beware: IE11 and Chrome 41 don't like using the listener as the\r\n            // options object. Figure out how to deal w/ this in IE11 - maybe\r\n            // patch addEventListener?\r\n            this.element.addEventListener(this.name, this, newListener);\r\n        }\r\n        \r\n        this._$committedValue = newListener;\r\n    }\r\n    \r\n    handleEvent(event) {\r\n        if (typeof this._$committedValue === 'function') {\r\n            this._$committedValue.call(this.options?.host ?? this.element, event);\r\n        } else {\r\n            this._$committedValue.handleEvent(event);\r\n        }\r\n    }\r\n}","import { nothing } from '../../../symbols.mjs'\r\nimport { PartType } from '../../../types.mjs';\r\nimport { ENABLE_EXTRA_SECURITY_HOOKS, sanityze } from '../../sanitizer.mjs';\r\n\r\nimport { AttributePart } from './AttributePart.mjs';\r\n\r\nexport class PropertyPart extends AttributePart {\r\n\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = PartType.PROPERTY;\r\n    }\r\n\r\n    /** @internal */\r\n    _commitValue(value) {\r\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n            if (this._sanitizer === undefined) {\r\n                this._sanitizer = sanityze(this.element, this.name, 'property');\r\n            }\r\n            value = this._sanitizer(value);\r\n        }\r\n        this.element[this.name] = value === nothing ? undefined : value;\r\n    }\r\n}","\r\nimport { ResultType } from '../../types.mjs';\r\nimport { boundAttributeSuffix, marker, nodeMarker } from '../../shared.mjs';\r\nimport { trustFromTemplateString } from '../sanitizer.mjs';\r\n\r\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\r\n\r\nconst COMMENT_START = 1;\r\nconst TAG_NAME = 2;\r\nconst DYNAMIC_TAG_NAME = 3;\r\n\r\nconst ENTIRE_MATCH = 0;\r\nconst ATTRIBUTE_NAME = 1;\r\nconst SPACES_AND_EQUALS = 2;\r\nconst QUOTE_CHAR = 3;\r\n\r\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\r\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\r\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\r\n\r\nconst commentEndRegex = /-->/g;\r\nconst comment2EndRegex = />/g;\r\nconst singleQuoteAttrEndRegex = /'/g;\r\nconst doubleQuoteAttrEndRegex = /\"/g;\r\n\r\n/**\r\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\r\n * position. It either matches a `>`, an attribute-like sequence, or the end\r\n * of the string after a space (attribute-name position ending).\r\n *\r\n * See attributes in the HTML spec:\r\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\r\n *\r\n * \" \\t\\n\\f\\r\" are HTML space characters:\r\n * https://infra.spec.whatwg.org/#ascii-whitespace\r\n *\r\n * So an attribute is:\r\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\r\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\r\n *  * Followed by zero or more space characters\r\n *  * Followed by \"=\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by:\r\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\r\n *    * (\") then any non-(\"), or\r\n *    * (') then any non-(')\r\n */\r\nconst tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`, 'g');\r\n\r\n\r\n/**\r\n * Matches the raw text elements.\r\n *\r\n * Comments are not parsed within raw text elements, so we need to search their\r\n * text content for marker strings.\r\n */\r\nexport const rawTextElement = /^(?:script|style|textarea|title)$/i;\r\n\r\n/**\r\n * Returns an HTML string for the given TemplateStringsArray and result type\r\n * (HTML or SVG), along with the case-sensitive bound attribute names in\r\n * template order. The HTML contains comment markers denoting the `ChildPart`s\r\n * and suffixes on bound attributes denoting the `AttributeParts`.\r\n *\r\n * @param strings template strings array\r\n * @param type HTML or SVG\r\n * @return Array containing `[html, attrNames]` (array returned for terseness,\r\n *     to avoid object fields since this code is shared with non-minified SSR\r\n *     code)\r\n */\r\nexport const getTemplateHtml = (strings, type) => {\r\n    \r\n    // Insert makers into the template HTML to represent the position of\r\n    // bindings. The following code scans the template strings to determine the\r\n    // syntactic position of the bindings. They can be in text position, where\r\n    // we insert an HTML comment, attribute value position, where we insert a\r\n    // sentinel string and re-write the attribute name, or inside a tag where\r\n    // we insert the sentinel string.\r\n    const l = strings.length - 1;\r\n    \r\n    // Stores the case-sensitive bound attribute names in the order of their\r\n    // parts. ElementParts are also reflected in this array as undefined\r\n    // rather than a string, to disambiguate from attribute bindings.\r\n    const attrNames = [];\r\n    let html = type === ResultType.SVG ? '<svg>' : '';\r\n    \r\n    // When we're inside a raw text tag (not it's text content), the regex\r\n    // will still be tagRegex so we can find attributes, but will switch to\r\n    // this regex when the tag ends.\r\n    let rawTextEndRegex;\r\n    \r\n    // The current parsing state, represented as a reference to one of the\r\n    // regexes\r\n    let regex = textEndRegex;\r\n\r\n    for (let i = 0; i < l; i++) {\r\n        \r\n        const s = strings[i];\r\n        // The index of the end of the last attribute name. When this is\r\n        // positive at end of a string, it means we're in an attribute value\r\n        // position and need to rewrite the attribute name.\r\n        // We also use a special value of -2 to indicate that we encountered\r\n        // the end of a string in attribute name position.\r\n        let attrNameEndIndex = -1;\r\n        let attrName;\r\n        let lastIndex = 0;\r\n        let match;\r\n\r\n        // The conditions in this loop handle the current parse state, and the\r\n        // assignments to the `regex` variable are the state transitions.\r\n        while (lastIndex < s.length) {\r\n            \r\n            // Make sure we start searching from where we previously left off\r\n            regex.lastIndex = lastIndex;\r\n            match = regex.exec(s);\r\n            \r\n            if (match === null) {\r\n                break;\r\n            }\r\n            \r\n            lastIndex = regex.lastIndex;\r\n\r\n            if (regex === textEndRegex) {\r\n                if (match[COMMENT_START] === '!--') {\r\n                    regex = commentEndRegex;\r\n                } else if (match[COMMENT_START] !== undefined) {\r\n                    // We started a weird comment, like </{\r\n                    regex = comment2EndRegex;\r\n                } else if (match[TAG_NAME] !== undefined) {\r\n                    if (rawTextElement.test(match[TAG_NAME])) {\r\n                        // Record if we encounter a raw-text element. We'll switch to\r\n                        // this regex at the end of the tag.\r\n                        rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\r\n                    }\r\n                    regex = tagEndRegex;\r\n                } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\r\n                    regex = tagEndRegex;\r\n                }\r\n\r\n            } else if (regex === tagEndRegex) {\r\n                if (match[ENTIRE_MATCH] === '>') {\r\n                    // End of a tag. If we had started a raw-text element, use that\r\n                    // regex\r\n                    regex = rawTextEndRegex ?? textEndRegex;\r\n                    // We may be ending an unquoted attribute value, so make sure we\r\n                    // clear any pending attrNameEndIndex\r\n                    attrNameEndIndex = -1;\r\n                } else if (match[ATTRIBUTE_NAME] === undefined) {\r\n                    // Attribute name position\r\n                    attrNameEndIndex = -2;\r\n                } else {\r\n                    attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\r\n                    attrName = match[ATTRIBUTE_NAME];\r\n                    regex =\r\n                        match[QUOTE_CHAR] === undefined\r\n                            ? tagEndRegex\r\n                            : match[QUOTE_CHAR] === '\"'\r\n                                ? doubleQuoteAttrEndRegex\r\n                                : singleQuoteAttrEndRegex;\r\n                }\r\n            } else if (regex === doubleQuoteAttrEndRegex ||\r\n                regex === singleQuoteAttrEndRegex) {\r\n                regex = tagEndRegex;\r\n            } else if (regex === commentEndRegex || regex === comment2EndRegex) {\r\n                regex = textEndRegex;\r\n            } else {\r\n                // Not one of the five state regexes, so it must be the dynamically\r\n                // created raw text regex and we're at the close of that element.\r\n                regex = tagEndRegex;\r\n                rawTextEndRegex = undefined;\r\n            }\r\n        }\r\n\r\n        // We have four cases:\r\n        //  1. We're in text position, and not in a raw text element\r\n        //     (regex === textEndRegex): insert a comment marker.\r\n        //  2. We have a non-negative attrNameEndIndex which means we need to\r\n        //     rewrite the attribute name to add a bound attribute suffix.\r\n        //  3. We're at the non-first binding in a multi-binding attribute, use a\r\n        //     plain marker.\r\n        //  4. We're somewhere else inside the tag. If we're in attribute name\r\n        //     position (attrNameEndIndex === -2), add a sequential suffix to\r\n        //     generate a unique attribute name.\r\n        // Detect a binding next to self-closing tag end and insert a space to\r\n        // separate the marker from the tag end:\r\n        const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\r\n        html +=\r\n            regex === textEndRegex\r\n                ? s + nodeMarker\r\n                : attrNameEndIndex >= 0\r\n                    ? (attrNames.push(attrName),\r\n                        s.slice(0, attrNameEndIndex) +\r\n                            boundAttributeSuffix +\r\n                            s.slice(attrNameEndIndex)) +\r\n                        marker +\r\n                        end\r\n                    : s + marker + (attrNameEndIndex === -2 ? i : end);\r\n    }\r\n\r\n    const htmlResult = html + (strings[l] || '<?>') + (type === ResultType.SVG ? '</svg>' : '');\r\n \r\n    // Returned as an array for terseness\r\n    return [trustFromTemplateString(strings, htmlResult), attrNames];\r\n}","import { typeSymbol } from '../../symbols.mjs';\r\nimport { PartType, ResultType } from '../../types.mjs';\r\nimport { boundAttributeSuffix, createMarker, marker, markerMatch, walker } from '../../shared.mjs';\r\nimport { AttributePart, EventPart, PropertyPart, BooleanAttributePart } from '../parts/attribute/index.mjs';\r\n\r\nimport { getTemplateHtml, rawTextElement } from './TemplateRenderer.mjs';\r\n\r\nexport class Template {\r\n\r\n    static createElement(html, _options) {\r\n        const el = document.createElement('template');\r\n        el.innerHTML = html;\r\n        return el;\r\n    }\r\n\r\n    #nodeIndex = 0;\r\n    #attrNameIndex = 0;\r\n\r\n    constructor({ strings, [typeSymbol]: type }, options) {\r\n\r\n        const partCount = strings.length - 1;\r\n        \r\n        // Create template element\r\n        const [html, attrNames] = getTemplateHtml(strings, type);\r\n        \r\n        const me = this;\r\n        me.parts = [];\r\n        me.el = Template.createElement(html, options);\r\n        \r\n        me.#handleSVG(type);\r\n        me.#handleTemplate(partCount, attrNames);\r\n    }\r\n\r\n    #handleSVG(type) {\r\n        // Re-parent SVG nodes into template root\r\n        if (type === ResultType.SVG) {\r\n            const svgElement = this.el.content.firstChild;\r\n            svgElement.replaceWith(...svgElement.childNodes);\r\n        }\r\n    }\r\n\r\n    // Walk the template to find binding markers and create TemplateParts\r\n    #handleTemplate(partCount, attrNames) {\r\n        \r\n        const me = this;\r\n        const parts = me.parts;\r\n        let node;\r\n        \r\n        me.#nodeIndex = 0;\r\n        me.#attrNameIndex = 0;\r\n        walker.currentNode = me.el.content;\r\n\r\n        while ((node = walker.nextNode()) !== null && parts.length < partCount) {\r\n            if (node.nodeType === 1) {\r\n                me.#handleElement(node, attrNames);\r\n            } else if (node.nodeType === 8) {\r\n                me.#handleComment(node);\r\n            }\r\n            me.#nodeIndex++;\r\n        }        \r\n    }\r\n\r\n    #handleElement(node, attrNames) {\r\n\r\n        const me = this;\r\n\r\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\r\n        // increment the bindingIndex, and it'll be off by 1 in the element\r\n        // and off by two after it.\r\n        if (node.hasAttributes()) {\r\n            me.#handleAttributes(node, attrNames);\r\n        }\r\n\r\n        if (rawTextElement.test(node.tagName)) {\r\n            me.#handleText(node);\r\n        }\r\n\r\n    }\r\n\r\n    #handleAttributes(node, attrNames) {\r\n        \r\n        const me = this;\r\n        const parts = me.parts;\r\n\r\n        for (const name of node.getAttributeNames()) {\r\n            if (name.endsWith(boundAttributeSuffix)) {\r\n                const realName = attrNames[me.#attrNameIndex++];\r\n                const value = node.getAttribute(name);\r\n                const statics = value.split(marker);\r\n                const m = /([.?@])?(.*)/.exec(realName);\r\n                parts.push({\r\n                    type: PartType.ATTRIBUTE,\r\n                    index: me.#nodeIndex,\r\n                    name: m[2],\r\n                    strings: statics,\r\n                    ctor: m[1] === '.'\r\n                        ? PropertyPart\r\n                        : m[1] === '?'\r\n                            ? BooleanAttributePart\r\n                            : m[1] === '@'\r\n                                ? EventPart\r\n                                : AttributePart,\r\n                });\r\n                node.removeAttribute(name);\r\n            } else if (name.startsWith(marker)) {\r\n                parts.push({\r\n                    type: PartType.ELEMENT,\r\n                    index: me.#nodeIndex,\r\n                });\r\n                node.removeAttribute(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    #handleText(node) {\r\n\r\n        const me = this;\r\n        const parts = me.parts;\r\n        const strings = node.textContent.split(marker);\r\n        const lastIndex = strings.length - 1;\r\n\r\n        if (lastIndex > 0) {\r\n            node.textContent = trustedTypes\r\n                ? trustedTypes.emptyScript\r\n                : '';\r\n\r\n            for (let i = 0; i < lastIndex; i++) {\r\n                node.append(strings[i], createMarker());\r\n                // Walk past the marker node we just added\r\n                walker.nextNode();\r\n                parts.push({ type: PartType.CHILD, index: ++me.#nodeIndex });\r\n            }\r\n            node.append(strings[lastIndex], createMarker());\r\n        }\r\n    }\r\n\r\n    #handleComment(node) {\r\n        const me = this;\r\n        const parts = me.parts;\r\n        const data = node.data;\r\n        if (data === markerMatch) {\r\n            parts.push({ type: PartType.CHILD, index: me.#nodeIndex });\r\n        } else {\r\n            let i = -1;\r\n            while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\r\n                parts.push({ type: PartType.COMMENT, index: me.#nodeIndex });\r\n                i += marker.length - 1;\r\n            }\r\n        }\r\n    }\r\n}","import { PartType } from '../../../types.mjs';\r\nimport { nothing, noChange, typeSymbol } from '../../../symbols.mjs';\r\nimport { createMarker, isArray, isPrimitive, isIterable } from '../../../shared.mjs';\r\nimport { ENABLE_EXTRA_SECURITY_HOOKS, isNoOp, createSanitizer } from '../../sanitizer.mjs';\r\n\r\nimport { BasePart } from '../BasePart.mjs';\r\nimport { Template } from '../../template/Template.mjs';\r\nimport { TemplateInstance } from '../../template/TemplateInstance.mjs';\r\n\r\nexport class ChildPart extends BasePart {\r\n\r\n    /**\r\n     * The cache of prepared templates, keyed by the tagged TemplateStringsArray\r\n     * and _not_ accounting for the specific template tag used. This means that\r\n     * template tags cannot be dynamic - the must statically be one of html, svg,\r\n     * or attr. This restriction simplifies the cache lookup, which is on the hot\r\n     * path for rendering.\r\n     */\r\n    static #templateCache = new WeakMap();\r\n\r\n\r\n    // See comment in Disconnectable interface for why this is a getter\r\n    get _$isConnected() {\r\n        // ChildParts that are not at the root should always be created with a\r\n        // parent; only RootChildNode's won't, so they return the local isConnected\r\n        // state\r\n        return this._$parent?._$isConnected ?? this.__isConnected;\r\n    }\r\n\r\n    constructor(startNode, endNode, parent, options) {\r\n        super(startNode, endNode, parent, options);\r\n        this.type = PartType.CHILD;\r\n        this._$committedValue = nothing;\r\n        // The following fields will be patched onto ChildParts when required by\r\n        // AsyncDirective\r\n        /** @internal */\r\n        this._$disconnectableChildren = undefined;\r\n        this._$startNode = startNode;\r\n        this._$endNode = endNode;\r\n        this._$parent = parent;\r\n        this.options = options;\r\n        // Note __isConnected is only ever accessed on RootParts (i.e. when there is\r\n        // no _$parent); the value on a non-root-part is \"don't care\", but checking\r\n        // for parent would be more code\r\n        this.__isConnected = options?.isConnected ?? true;\r\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n            // Explicitly initialize for consistent class shape.\r\n            this._textSanitizer = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The parent node into which the part renders its content.\r\n     *\r\n     * A ChildPart's content consists of a range of adjacent child nodes of\r\n     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\r\n     * `.endNode`).\r\n     *\r\n     * - If both `.startNode` and `.endNode` are non-null, then the part's content\r\n     * consists of all siblings between `.startNode` and `.endNode`, exclusively.\r\n     *\r\n     * - If `.startNode` is non-null but `.endNode` is null, then the part's\r\n     * content consists of all siblings following `.startNode`, up to and\r\n     * including the last child of `.parentNode`. If `.endNode` is non-null, then\r\n     * `.startNode` will always be non-null.\r\n     *\r\n     * - If both `.endNode` and `.startNode` are null, then the part's content\r\n     * consists of all child nodes of `.parentNode`.\r\n     */\r\n    get parentNode() {\r\n        let parentNode = this._$startNode.parentNode;\r\n        const parent = this._$parent;\r\n        if (parent !== undefined &&\r\n            parentNode?.nodeType === 11 /* Node.DOCUMENT_FRAGMENT */) {\r\n            // If the parentNode is a DocumentFragment, it may be because the DOM is\r\n            // still in the cloned fragment during initial render; if so, get the real\r\n            // parentNode the part will be committed into by asking the parent.\r\n            parentNode = parent.parentNode;\r\n        }\r\n        return parentNode;\r\n    }\r\n    /**\r\n     * The part's leading marker node, if any. See `.parentNode` for more\r\n     * information.\r\n     */\r\n    get startNode() {\r\n        return this._$startNode;\r\n    }\r\n    /**\r\n     * The part's trailing marker node, if any. See `.parentNode` for more\r\n     * information.\r\n     */\r\n    get endNode() {\r\n        return this._$endNode;\r\n    }\r\n\r\n    _$setValue(value, directiveParent = this) {\r\n        value = this.resolveDirective(this, value, directiveParent);\r\n        if (isPrimitive(value)) {\r\n            if (value === nothing || value == null || value === '') {\r\n                if (this._$committedValue !== nothing) {\r\n                    this._$clear();\r\n                }\r\n                this._$committedValue = nothing;\r\n            } else if (value !== this._$committedValue && value !== noChange) {\r\n                this._commitText(value);\r\n            }\r\n            // This property needs to remain unminified.\r\n        } else if (value[typeSymbol] !== undefined) {\r\n            this._commitTemplateResult(value);\r\n        } else if (value.nodeType !== undefined) {\r\n            this._commitNode(value);\r\n        } else if (isIterable(value)) {\r\n            this._commitIterable(value);\r\n        } else {\r\n            this._commitText(value);\r\n        }\r\n    }\r\n\r\n    _insert(node) {\r\n        return this._$startNode.parentNode.insertBefore(node, this._$endNode);\r\n    }\r\n\r\n    _commitNode(value) {\r\n        if (this._$committedValue !== value) {\r\n            this._$clear();\r\n            if (ENABLE_EXTRA_SECURITY_HOOKS && !isNoOp) {\r\n                const parentNodeName = this._$startNode.parentNode?.nodeName;\r\n                if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\r\n                    let message = 'Forbidden';\r\n                    throw new Error(message);\r\n                }\r\n            }\r\n            this._$committedValue = this._insert(value);\r\n        }\r\n    }\r\n\r\n    _commitText(value) {\r\n        if (this._$committedValue !== nothing &&\r\n            isPrimitive(this._$committedValue)) {\r\n            const node = this._$startNode.nextSibling;\r\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n                if (this._textSanitizer === undefined) {\r\n                    this._textSanitizer = createSanitizer(node, 'data', 'property');\r\n                }\r\n                value = this._textSanitizer(value);\r\n            }\r\n            node.data = value;\r\n        } else {\r\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n                const textNode = document.createTextNode('');\r\n                this._commitNode(textNode);\r\n                if (this._textSanitizer === undefined) {\r\n                    this._textSanitizer = createSanitizer(textNode, 'data', 'property');\r\n                }\r\n                value = this._textSanitizer(value);\r\n                textNode.data = value;\r\n            } else {\r\n                this._commitNode(document.createTextNode(value));\r\n            }\r\n        }\r\n        this._$committedValue = value;\r\n    }\r\n\r\n    _commitTemplateResult(result) {\r\n        const { values, [typeSymbol]: type } = result;\r\n\r\n        const template = typeof type === 'number'\r\n            ? this._$getTemplate(result)\r\n            : (type.el === undefined &&\r\n                (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)), type);\r\n        if (this._$committedValue?._$template === template) {\r\n            this._$committedValue._update(values);\r\n        } else {\r\n            const instance = new TemplateInstance(template, this);\r\n            const fragment = instance._clone(this.options);\r\n            instance._update(values);\r\n            this._commitNode(fragment);\r\n            this._$committedValue = instance;\r\n        }\r\n    }\r\n\r\n    _$getTemplate(result) {\r\n        const cache = ChildPart.#templateCache;\r\n        let template = cache.get(result.strings);\r\n        if (template === undefined) {\r\n            cache.set(result.strings, (template = new Template(result)));\r\n        }\r\n        return template;\r\n    }\r\n\r\n    _commitIterable(value) {\r\n\r\n        if (!isArray(this._$committedValue)) {\r\n            this._$committedValue = [];\r\n            this._$clear();\r\n        }\r\n\r\n        // Lets us keep track of how many items we stamped so we can clear leftover\r\n        // items from a previous render\r\n        const itemParts = this._$committedValue;\r\n        let partIndex = 0;\r\n        let itemPart;\r\n\r\n        for (const item of value) {\r\n            if (partIndex === itemParts.length) {\r\n                // If no existing part, create a new one\r\n                // TODO (justinfagnani): test perf impact of always creating two parts\r\n                // instead of sharing parts between nodes\r\n                // https://github.com/lit/lit/issues/1266\r\n                itemParts.push((itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)));\r\n            } else {\r\n                // Reuse an existing part\r\n                itemPart = itemParts[partIndex];\r\n            }\r\n            itemPart._$setValue(item);\r\n            partIndex++;\r\n        }\r\n\r\n        if (partIndex < itemParts.length) {\r\n            // itemParts always have end nodes\r\n            this._$clear(itemPart && itemPart._$endNode.nextSibling, partIndex);\r\n            // Truncate the parts array so _value reflects the current state\r\n            itemParts.length = partIndex;\r\n        }\r\n    }\r\n\r\n    _$clear(start = this._$startNode.nextSibling, from) {\r\n        this._$notifyConnectionChanged?.(false, true, from);\r\n        while (start && start !== this._$endNode) {\r\n            const n = start.nextSibling;\r\n            start.remove();\r\n            start = n;\r\n        }\r\n    }\r\n\r\n    setConnected(isConnected) {\r\n        if (this._$parent === undefined) {\r\n            this.__isConnected = isConnected;\r\n            this._$notifyConnectionChanged?.(isConnected);\r\n        }\r\n    }\r\n}","import { PartType } from '../../../types.mjs';\r\nimport { BasePart } from '../BasePart.mjs';\r\n\r\nexport class ElementPart extends BasePart {\r\n\r\n    constructor(element, parent, options) {\r\n        super(element, parent, options);\r\n        this.element = element;\r\n        this.type = PartType.ELEMENT;\r\n        /** @internal */\r\n        this._$disconnectableChildren = undefined;\r\n        this._$parent = parent;\r\n        this.options = options;\r\n    }\r\n\r\n    // See comment in Disconnectable interface for why this is a getter\r\n    get _$isConnected() {\r\n        return this._$parent._$isConnected;\r\n    }\r\n\r\n    _$setValue(value) {\r\n        this.resolveDirective(this, value);\r\n    }\r\n}\r\n","import { PartType } from '../../types.mjs';\r\nimport { walker } from '../../shared.mjs';\r\nimport { ChildPart } from '../parts/element/ChildPart.mjs';\r\nimport { ElementPart } from '../parts/element/ElementPart.mjs';\r\n\r\n/**\r\n * An updateable instance of a Template. Holds references to the Parts used to\r\n * update the template instance.\r\n */\r\nexport class TemplateInstance {\r\n\r\n    constructor(template, parent) {\r\n        this._$parts = [];\r\n        /** @internal */\r\n        this._$disconnectableChildren = undefined;\r\n        this._$template = template;\r\n        this._$parent = parent;\r\n    }\r\n\r\n    // Called by ChildPart parentNode getter\r\n    get parentNode() {\r\n        return this._$parent.parentNode;\r\n    }\r\n\r\n    // See comment in Disconnectable interface for why this is a getter\r\n    get _$isConnected() {\r\n        return this._$parent._$isConnected;\r\n    }\r\n\r\n    _clone(options) {\r\n\r\n        const { el: { content }, parts: parts, } = this._$template;\r\n        const fragment = (options?.creationScope ?? document).importNode(content, true);\r\n\r\n        walker.currentNode = fragment;\r\n\r\n        let node = walker.nextNode();\r\n        let nodeIndex = 0;\r\n        let partIndex = 0;\r\n        let templatePart = parts[0];\r\n\r\n        while (templatePart !== undefined) {\r\n\r\n            if (nodeIndex === templatePart.index) {\r\n                let part;\r\n                if (templatePart.type === PartType.CHILD) {\r\n                    part = new ChildPart(node, node.nextSibling, this, options);\r\n                } else if (templatePart.type === PartType.ATTRIBUTE) {\r\n                    part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);\r\n                } else if (templatePart.type === PartType.ELEMENT) {\r\n                    part = new ElementPart(node, this, options);\r\n                }\r\n                this._$parts.push(part);\r\n                templatePart = parts[++partIndex];\r\n            }\r\n\r\n            if (nodeIndex !== templatePart?.index) {\r\n                node = walker.nextNode();\r\n                nodeIndex++;\r\n            }\r\n        }\r\n\r\n        walker.currentNode = document;\r\n        return fragment;\r\n    }\r\n\r\n    _update(values) {\r\n        let i = 0;\r\n        for (const part of this._$parts) {\r\n            if (part !== undefined) {\r\n                if (part.strings !== undefined) {\r\n                    part._$setValue(values, part, i);\r\n                    i += part.strings.length - 2;\r\n                } else {\r\n                    part._$setValue(values[i]);\r\n                }\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n}","import { partSymbol, typeSymbol } from '../symbols.mjs';\r\nimport { ResultType } from '../types.mjs';\r\nimport { createMarker } from '../shared.mjs';\r\nimport { ChildPart } from './parts/element/ChildPart.mjs';\r\nimport { ENABLE_EXTRA_SECURITY_HOOKS, setSanitizer, createSanitizer } from './sanitizer.mjs';\r\n\r\nexport class DynamicHTML {\r\n\r\n    /**\r\n     * Generates a template literal tag function that returns a TemplateResult with\r\n     * the given result type.\r\n     */\r\n    static #tag = (type) => (strings, ...values) => {\r\n        return {\r\n            [typeSymbol]: type,\r\n            strings,\r\n            values,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Interprets a template literal as an HTML template that can efficiently\r\n     * render to and update a container.\r\n     *\r\n     * ```ts\r\n     * const header = (title: string) => html`<h1>${title}</h1>`;\r\n     * ```\r\n     *\r\n     * The `html` tag returns a description of the DOM to render as a value. It is\r\n     * lazy, meaning no work is done until the template is rendered. When rendering,\r\n     * if a template comes from the same expression as a previously rendered result,\r\n     * it's efficiently updated instead of replaced.\r\n     */\r\n    static html = DynamicHTML.#tag(ResultType.HTML);\r\n\r\n    /**\r\n     * Interprets a template literal as an SVG fragment that can efficiently\r\n     * render to and update a container.\r\n     *\r\n     * ```ts\r\n     * const rect = svg`<rect width=\"10\" height=\"10\"></rect>`;\r\n     *\r\n     * const myImage = html`\r\n     *   <svg viewBox=\"0 0 10 10\" xmlns=\"http://www.w3.org/2000/svg\">\r\n     *     ${rect}\r\n     *   </svg>`;\r\n     * ```\r\n     *\r\n     * The `svg` *tag function* should only be used for SVG fragments, or elements\r\n     * that would be contained **inside** an `<svg>` HTML element. A common error is\r\n     * placing an `<svg>` *element* in a template tagged with the `svg` tag\r\n     * function. The `<svg>` element is an HTML element and should be used within a\r\n     * template tagged with the {@linkcode html} tag function.\r\n     *\r\n     * In LitElement usage, it's invalid to return an SVG fragment from the\r\n     * `render()` method, as the SVG fragment will be contained within the element's\r\n     * shadow root and thus cannot be used within an `<svg>` HTML element.\r\n     */\r\n    static svg = DynamicHTML.#tag(ResultType.SVG);\r\n\r\n\r\n    /**\r\n     * Renders a value, usually a dynamic TemplateResult, to the container.\r\n     *\r\n     * This example renders the text \"Hello, Zoe!\" inside a paragraph tag, appending\r\n     * it to the container `document.body`.\r\n     *\r\n     * ```js\r\n     * import {html, render} from 'lit';\r\n     *\r\n     * const name = \"Zoe\";\r\n     * render(html`<p>Hello, ${name}!</p>`, document.body);\r\n     * ```\r\n     *\r\n     * @param value Any [renderable\r\n     *   value](https://lit.dev/docs/templates/expressions/#child-expressions),\r\n     *   typically a {@linkcode TemplateResult} created by evaluating a template tag\r\n     *   like {@linkcode html} or {@linkcode svg}.\r\n     * @param container A DOM container to render to. The first render will append\r\n     *   the rendered value to the container, and subsequent renders will\r\n     *   efficiently update the rendered value if the same result type was\r\n     *   previously rendered there.\r\n     * @param options See {@linkcode RenderOptions} for options documentation.\r\n     */\r\n    static render(value, container, options) {\r\n        const partOwnerNode = options?.renderBefore ?? container;\r\n        let part = partOwnerNode[partSymbol];\r\n        if (part === undefined) {\r\n            const endNode = options?.renderBefore ?? null;\r\n            partOwnerNode[partSymbol] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, undefined, options ?? {});\r\n        }\r\n        part._$setValue(value);\r\n        return part;\r\n    }\r\n\r\n    static {\r\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\r\n            DynamicHTML.render.setSanitizer = setSanitizer;\r\n            DynamicHTML.render.createSanitizer = createSanitizer;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// for compatibility with Lit 3.0\r\nexport const html = DynamicHTML.html;\r\nexport const svg = DynamicHTML.svg;\r\nexport const render = DynamicHTML.render;","import { DynamicHTML } from './dynamic/dynamic.mjs';\r\n\r\nexport class StaticHTML {\r\n\r\n    /**\r\n     * Prevents JSON injection attacks.\r\n     *\r\n     * The goals of this brand:\r\n     *   1) fast to check\r\n     *   2) code is small on the wire\r\n     *   3) multiple versions of Lit in a single page will all produce mutually\r\n     *      interoperable StaticValues\r\n     *   4) normal JSON.parse (without an unusual reviver) can not produce a\r\n     *      StaticValue\r\n     *\r\n     * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but\r\n     * we don't care about the key, so we break ties via (2) and use the empty\r\n     * string.\r\n     */\r\n    static #brand = Symbol.for('');\r\n    static #propertySymbol = Symbol('_$static$');\r\n\r\n    static #stringsCache = new Map();\r\n\r\n    /** Safely extracts the string part of a StaticValue. */\r\n    static #unwrapStaticValue = (value) => {\r\n        if (value?.r !== StaticHTML.#brand) {\r\n            return undefined;\r\n        }\r\n        return value?.[StaticHTML.#propertySymbol];\r\n    }\r\n\r\n    static #textFromStatic = (value) => {\r\n        if (value[StaticHTML.#propertySymbol] !== undefined) {\r\n            return value[StaticHTML.#propertySymbol];\r\n        } else {\r\n            throw new Error(`Value passed to 'literal' function must be a 'literal' result: ${value}. Use 'unsafeStatic' to pass non-literal values, but take care to ensure page security.`);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Wraps a string so that it behaves like part of the static template\r\n     * strings instead of a dynamic value.\r\n     *\r\n     * Users must take care to ensure that adding the static string to the template\r\n     * results in well-formed HTML, or else templates may break unexpectedly.\r\n     *\r\n     * Note that this function is unsafe to use on untrusted content, as it will be\r\n     * directly parsed into HTML. Do not pass user input to this function\r\n     * without sanitizing it.\r\n     *\r\n     * Static values can be changed, but they will cause a complete re-render\r\n     * since they effectively create a new template.\r\n     */\r\n    static unsafeStatic = (value) => ({\r\n        [StaticHTML.#propertySymbol]: value,\r\n        r: StaticHTML.#brand,\r\n    })\r\n\r\n    /**\r\n     * Tags a string literal so that it behaves like part of the static template\r\n     * strings instead of a dynamic value.\r\n     *\r\n     * The only values that may be used in template expressions are other tagged\r\n     * `literal` results or `unsafeStatic` values (note that untrusted content\r\n     * should never be passed to `unsafeStatic`).\r\n     *\r\n     * Users must take care to ensure that adding the static string to the template\r\n     * results in well-formed HTML, or else templates may break unexpectedly.\r\n     *\r\n     * Static values can be changed, but they will cause a complete re-render since\r\n     * they effectively create a new template.\r\n     */\r\n    static literal = (strings, ...values) => ({\r\n        [StaticHTML.#propertySymbol]: values.reduce((acc, v, idx) => acc + StaticHTML.#textFromStatic(v) + strings[idx + 1], strings[0]),\r\n        r: StaticHTML.#brand,\r\n    })\r\n\r\n    /**\r\n     * Wraps a dynamic template tag (`html` or `svg`) to add static value support.\r\n     */\r\n    static withStatic = (coreTag) => (strings, ...values) => {\r\n\r\n        const staticStrings = [];\r\n        const dynamicValues = [];\r\n\r\n        const l = values.length;\r\n\r\n        let staticValue;\r\n        let dynamicValue;\r\n        let hasStatics = false;\r\n        let i = 0;\r\n        let s;\r\n\r\n        while (i < l) {\r\n            s = strings[i];\r\n            // Collect any unsafeStatic values, and their following template strings\r\n            // so that we treat a run of template strings and unsafe static values as\r\n            // a single template string.\r\n            while (i < l &&\r\n                ((dynamicValue = values[i]),\r\n                    (staticValue =  StaticHTML.#unwrapStaticValue(dynamicValue))) !== undefined) {\r\n                s += staticValue + strings[++i];\r\n                hasStatics = true;\r\n            }\r\n            // If the last value is static, we don't need to push it.\r\n            if (i !== l) {\r\n                dynamicValues.push(dynamicValue);\r\n            }\r\n            staticStrings.push(s);\r\n            i++;\r\n        }\r\n\r\n        // If the last value isn't static (which would have consumed the last\r\n        // string), then we need to add the last string.\r\n        if (i === l) {\r\n            staticStrings.push(strings[l]);\r\n        }\r\n\r\n        if (hasStatics) {\r\n            const key = staticStrings.join('$$vlit$$');\r\n            strings = StaticHTML.#stringsCache.get(key);\r\n\r\n            if (strings === undefined) {\r\n                // Beware: in general this pattern is unsafe, and doing so may bypass\r\n                // lit's security checks and allow an attacker to execute arbitrary\r\n                // code and inject arbitrary content.\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                staticStrings.raw = staticStrings;\r\n                StaticHTML.#stringsCache.set(key, (strings = staticStrings));\r\n            }\r\n            values = dynamicValues;\r\n        }\r\n\r\n        return coreTag(strings, ...values);\r\n    }\r\n\r\n\r\n    /**\r\n     * Interprets a template literal as an HTML template that can efficiently\r\n     * render to and update a container.\r\n     *\r\n     * Includes static value support from `dynamic/static.js`.\r\n     */\r\n    static html = StaticHTML.withStatic(DynamicHTML.html);\r\n\r\n    /**\r\n     * Interprets a template literal as an SVG template that can efficiently\r\n     * render to and update a container.\r\n     *\r\n     * Includes static value support from `dynamic/static.js`.\r\n     */\r\n    static svg = StaticHTML.withStatic(DynamicHTML.svg);\r\n\r\n}\r\n\r\n// for compatibility with Lit 3.0\r\nexport const unsafeStatic = StaticHTML.unsafeStatic\r\nexport const withStatic = StaticHTML.withStatic;\r\nexport const literal = StaticHTML.literal;\r\nexport const staticHtml = StaticHTML.html;\r\nexport const staticSvg = StaticHTML.svg;\r\n","import { typeSymbol, directiveSymbol } from '../symbols.mjs';\r\nimport { ChildPart } from '../dynamic/parts/element/ChildPart.mjs';\r\n\r\n\r\n/**\r\n * Tests if a value is a TemplateResult or a CompiledTemplateResult.\r\n */\r\nexport const isTemplateResult = (value, type) => type === undefined\r\n    ? // This property needs to remain unminified.\r\n        value?.[typeSymbol] !== undefined\r\n    : value?.[typeSymbol] === type;\r\n\r\n/**\r\n * Tests if a value is a CompiledTemplateResult.\r\n */\r\nexport const isCompiledTemplateResult = (value) => {\r\n    return value?.[typeSymbol]?.h != null;\r\n}\r\n\r\n/**\r\n * Tests if a value is a DirectiveResult.\r\n */\r\nexport const isDirectiveResult = (value) => \r\n\r\n// This property needs to remain unminified.\r\nvalue?.[directiveSymbol] !== undefined;\r\n\r\n/**\r\n * Retrieves the Directive class for a DirectiveResult\r\n */\r\nexport const getDirectiveClass = (value) => \r\n\r\n// This property needs to remain unminified.\r\nvalue?.[directiveSymbol];\r\n\r\n/**\r\n * Tests whether a part has only a single-expression with no strings to\r\n * interpolate between.\r\n *\r\n * Only AttributePart and PropertyPart can have multiple expressions.\r\n * Multi-expression parts have a `strings` property and single-expression\r\n * parts do not.\r\n */\r\nexport const isSingleExpression = (part) => part.strings === undefined;\r\nconst createMarker = () => document.createComment('');\r\n\r\n/**\r\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\r\n * end of the container ChildPart, or before the optional `refPart`.\r\n *\r\n * This does not add the part to the containerPart's committed value. That must\r\n * be done by callers.\r\n *\r\n * @param containerPart Part within which to add the new ChildPart\r\n * @param refPart Part before which to add the new ChildPart; when omitted the\r\n *     part added to the end of the `containerPart`\r\n * @param part Part to insert, or undefined to create a new part\r\n */\r\nexport const insertPart = (containerPart, refPart, part) => {\r\n    const container = containerPart._$startNode.parentNode;\r\n    const refNode = refPart === undefined ? containerPart._$endNode : refPart._$startNode;\r\n    if (part === undefined) {\r\n        const startNode = (container).insertBefore(createMarker(), refNode);\r\n        const endNode = (container).insertBefore(createMarker(), refNode);\r\n        part = new ChildPart(startNode, endNode, containerPart, containerPart.options);\r\n    } else {\r\n        const endNode = (part._$endNode).nextSibling;\r\n        const oldParent = part._$parent;\r\n        const parentChanged = oldParent !== containerPart;\r\n        if (parentChanged) {\r\n            part._$reparentDisconnectables?.(containerPart);\r\n            // Note that although `_$reparentDisconnectables` updates the part's\r\n            // `_$parent` reference after unlinking from its current parent, that\r\n            // method only exists if Disconnectables are present, so we need to\r\n            // unconditionally set it here\r\n            part._$parent = containerPart;\r\n            // Since the _$isConnected getter is somewhat costly, only\r\n            // read it once we know the subtree has directives that need\r\n            // to be notified\r\n            let newConnectionState;\r\n            if (part._$notifyConnectionChanged !== undefined &&\r\n                (newConnectionState = containerPart._$isConnected) !==\r\n                    oldParent._$isConnected) {\r\n                part._$notifyConnectionChanged(newConnectionState);\r\n            }\r\n        }\r\n        if (endNode !== refNode || parentChanged) {\r\n            let start = part._$startNode;\r\n            while (start !== endNode) {\r\n                const n = (start).nextSibling;\r\n                (container).insertBefore(start, refNode);\r\n                start = n;\r\n            }\r\n        }\r\n    }\r\n    return part;\r\n}\r\n\r\n/**\r\n * Sets the value of a Part.\r\n *\r\n * Note that this should only be used to set/update the value of user-created\r\n * parts (i.e. those created using `insertPart`); it should not be used\r\n * by directives to set the value of the directive's container part. Directives\r\n * should return a value from `update`/`render` to update their part state.\r\n *\r\n * For directives that require setting their part value asynchronously, they\r\n * should extend `AsyncDirective` and call `this.setValue()`.\r\n *\r\n * @param part Part to set\r\n * @param value Value to set\r\n * @param index For `AttributePart`s, the index to set\r\n * @param directiveParent Used internally; should not be set by user\r\n */\r\nexport const setChildPartValue = (part, value, directiveParent = part) => {\r\n    part._$setValue(value, directiveParent);\r\n    return part;\r\n}\r\n\r\n// A sentinel value that can never appear as a part value except when set by\r\n// live(). Used to force a dirty-check to fail and cause a re-render.\r\nconst RESET_VALUE = {};\r\n\r\n/**\r\n * Sets the committed value of a ChildPart directly without triggering the\r\n * commit stage of the part.\r\n *\r\n * This is useful in cases where a directive needs to update the part such\r\n * that the next update detects a value change or not. When value is omitted,\r\n * the next update will be guaranteed to be detected as a change.\r\n *\r\n * @param part\r\n * @param value\r\n */\r\nexport const setCommittedValue = (part, value = RESET_VALUE) => (part._$committedValue = value);\r\n\r\n/**\r\n * Returns the committed value of a ChildPart.\r\n *\r\n * The committed value is used for change detection and efficient updates of\r\n * the part. It can differ from the value set by the template or directive in\r\n * cases where the template value is transformed before being committed.\r\n *\r\n * - `TemplateResult`s are committed as a `TemplateInstance`\r\n * - Iterables are committed as `Array<ChildPart>`\r\n * - All other types are committed as the template value or value returned or\r\n *   set by a directive.\r\n *\r\n * @param part\r\n */\r\nexport const getCommittedValue = (part) => part._$committedValue;\r\n\r\n/**\r\n * Removes a ChildPart from the DOM, including any of its content.\r\n *\r\n * @param part The Part to remove\r\n */\r\nexport const removePart = (part) => {\r\n    part._$notifyConnectionChanged?.(false, true);\r\n    let start = part._$startNode;\r\n    const end = (part._$endNode).nextSibling;\r\n    while (start !== end) {\r\n        const n = (start).nextSibling;\r\n        (start).remove();\r\n        start = n;\r\n    }\r\n};\r\n\r\nexport const clearPart = (part) => {\r\n    part._$clear();\r\n}\r\n","import { directiveSymbol } from '../symbols.mjs';\r\n\r\n/**\r\n * Creates a user-facing directive function from a Directive class. This\r\n * function has the same parameters as the directive's render() method.\r\n */\r\nexport const directive = (c) => (...values) => ({\r\n    // This property needs to remain unminified.\r\n    [directiveSymbol]: c,\r\n    values,\r\n})\r\n\r\n/**\r\n * Base class for creating custom directives. Users should extend this class,\r\n * implement `render` and/or `update`, and then pass their subclass to\r\n * `directive`.\r\n */\r\nexport class Directive {\r\n  \r\n    constructor(_partInfo) { }\r\n  \r\n    get _$isConnected() {\r\n        return this._$parent._$isConnected;\r\n    }\r\n    \r\n    _$initialize(part, parent, attributeIndex) {\r\n        this.__part = part;\r\n        this._$parent = parent;\r\n        this.__attributeIndex = attributeIndex;\r\n    }\r\n    \r\n    _$resolve(part, props) {\r\n        return this.update(part, props);\r\n    }\r\n\r\n    update(_part, props) {\r\n        return this.render(...props);\r\n    }\r\n}\r\n","import { PartType } from '../types.mjs';\r\nimport { notifySymbol } from '../symbols.mjs';\r\nimport { isSingleExpression } from './directive-helpers.mjs';\r\nimport { Directive } from './directive.mjs';\r\n\r\n\r\n/**\r\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\r\n * the connected state of directives and run `disconnected`/ `reconnected`\r\n * callbacks.\r\n *\r\n * @return True if there were children to disconnect; false otherwise\r\n */\r\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\r\n\r\n    const children = parent._$disconnectableChildren;\r\n\r\n    if (children === undefined) {\r\n        return false;\r\n    }\r\n\r\n    for (const obj of children) {\r\n        // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\r\n        // disambiguate AsyncDirectives from other DisconnectableChildren\r\n        // (as opposed to using an instanceof check to know when to call it); the\r\n        // redundancy of \"Directive\" in the API name is to avoid conflicting with\r\n        // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\r\n        // this list\r\n        // Disconnect Directive (and any nested directives contained within)\r\n        // This property needs to remain unminified.\r\n        obj[notifySymbol]?.(isConnected, false);\r\n        // Disconnect Part/TemplateInstance\r\n        notifyChildrenConnectedChanged(obj, isConnected);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Removes the given child from its parent list of disconnectable children, and\r\n * if the parent list becomes empty as a result, removes the parent from its\r\n * parent, and so forth up the tree when that causes subsequent parent lists to\r\n * become empty.\r\n */\r\nconst removeDisconnectableFromParent = (obj) => {\r\n    let parent, children;\r\n    do {\r\n        if ((parent = obj._$parent) === undefined) {\r\n            break;\r\n        }\r\n        children = parent._$disconnectableChildren;\r\n        children.delete(obj);\r\n        obj = parent;\r\n    } while (children?.size === 0);\r\n}\r\n\r\nconst addDisconnectableToParent = (obj) => {\r\n    // Climb the parent tree, creating a sparse tree of children needing\r\n    // disconnection\r\n    for (let parent; (parent = obj._$parent); obj = parent) {\r\n        let children = parent._$disconnectableChildren;\r\n        if (children === undefined) {\r\n            parent._$disconnectableChildren = children = new Set();\r\n        }\r\n        else if (children.has(obj)) {\r\n            // Once we've reached a parent that already contains this child, we\r\n            // can short-circuit\r\n            break;\r\n        }\r\n        children.add(obj);\r\n        installDisconnectAPI(parent);\r\n    }\r\n}\r\n\r\n/**\r\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\r\n * Disconnectable children accordingly.\r\n *\r\n * Note, this method will be patched onto ChildPart instances and called from\r\n * the core code when parts are moved between different parents.\r\n */\r\nfunction reparentDisconnectables(newParent) {\r\n    if (this._$disconnectableChildren !== undefined) {\r\n        removeDisconnectableFromParent(this);\r\n        this._$parent = newParent;\r\n        addDisconnectableToParent(this);\r\n    }\r\n    else {\r\n        this._$parent = newParent;\r\n    }\r\n}\r\n\r\n/**\r\n * Sets the connected state on any directives contained within the committed\r\n * value of this part (i.e. within a TemplateInstance or iterable of\r\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\r\n * any directives stored on the ChildPart (when `valueOnly` is false).\r\n *\r\n * `isClearingValue` should be passed as `true` on a top-level part that is\r\n * clearing itself, and not as a result of recursively disconnecting directives\r\n * as part of a `clear` operation higher up the tree. This both ensures that any\r\n * directive on this ChildPart that produced a value that caused the clear\r\n * operation is not disconnected, and also serves as a performance optimization\r\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\r\n * subtree, only the top-most part need to remove itself from the parent.\r\n *\r\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\r\n * result of truncating an iterable.\r\n *\r\n * Note, this method will be patched onto ChildPart instances and called from the\r\n * core code when parts are cleared or the connection state is changed by the\r\n * user.\r\n */\r\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\r\n    \r\n    const value = this._$committedValue;\r\n    const children = this._$disconnectableChildren;\r\n    \r\n    if (children === undefined || children.size === 0) {\r\n        return;\r\n    }\r\n\r\n    if (isClearingValue) {\r\n        if (Array.isArray(value)) {\r\n            // Iterable case: Any ChildParts created by the iterable should be\r\n            // disconnected and removed from this ChildPart's disconnectable\r\n            // children (starting at `fromPartIndex` in the case of truncation)\r\n            for (let i = fromPartIndex; i < value.length; i++) {\r\n                notifyChildrenConnectedChanged(value[i], false);\r\n                removeDisconnectableFromParent(value[i]);\r\n            }\r\n        } else if (value != null) {\r\n            // TemplateInstance case: If the value has disconnectable children (will\r\n            // only be in the case that it is a TemplateInstance), we disconnect it\r\n            // and remove it from this ChildPart's disconnectable children\r\n            notifyChildrenConnectedChanged(value, false);\r\n            removeDisconnectableFromParent(value);\r\n        }\r\n    }  else {\r\n        notifyChildrenConnectedChanged(this, isConnected);\r\n    }\r\n}\r\n\r\n/**\r\n * Patches disconnection API onto ChildParts.\r\n */\r\nconst installDisconnectAPI = (obj) => {\r\n    if (obj.type == PartType.CHILD) {\r\n        obj._$notifyConnectionChanged ??=\r\n            notifyChildPartConnectedChanged;\r\n        obj._$reparentDisconnectables ??= reparentDisconnectables;\r\n    }\r\n}\r\n\r\n/**\r\n * An abstract `Directive` base class whose `disconnected` method will be\r\n * called when the part containing the directive is cleared as a result of\r\n * re-rendering, or when the user calls `part.setConnected(false)` on\r\n * a part that was previously rendered containing the directive (as happens\r\n * when e.g. a LitElement disconnects from the DOM).\r\n *\r\n * If `part.setConnected(true)` is subsequently called on a\r\n * containing part, the directive's `reconnected` method will be called prior\r\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\r\n * `reconnected` should also be implemented to be compatible with reconnection.\r\n *\r\n * Note that updates may occur while the directive is disconnected. As such,\r\n * directives should generally check the `this.isConnected` flag during\r\n * render/update to determine whether it is safe to subscribe to resources\r\n * that may prevent garbage collection.\r\n */\r\nexport class AsyncDirective extends Directive {\r\n    \r\n    constructor() {\r\n        super(...arguments);\r\n        // @internal\r\n        this._$disconnectableChildren = undefined;\r\n    }\r\n\r\n    /**\r\n     * Initialize the part with internal fields\r\n     * @param part\r\n     * @param parent\r\n     * @param attributeIndex\r\n     */\r\n    _$initialize(part, parent, attributeIndex) {\r\n        super._$initialize(part, parent, attributeIndex);\r\n        addDisconnectableToParent(this);\r\n        this.isConnected = part._$isConnected;\r\n    }\r\n    // This property needs to remain unminified.\r\n    /**\r\n     * Called from the core code when a directive is going away from a part (in\r\n     * which case `shouldRemoveFromParent` should be true), and from the\r\n     * `setChildrenConnected` helper function when recursively changing the\r\n     * connection state of a tree (in which case `shouldRemoveFromParent` should\r\n     * be false).\r\n     *\r\n     * @param isConnected\r\n     * @param isClearingDirective - True when the directive itself is being\r\n     *     removed; false when the tree is being disconnected\r\n     * @internal\r\n     */\r\n    [notifySymbol](isConnected, isClearingDirective = true) {\r\n        if (isConnected !== this.isConnected) {\r\n            this.isConnected = isConnected;\r\n            if (isConnected) {\r\n                this.reconnected?.();\r\n            }\r\n            else {\r\n                this.disconnected?.();\r\n            }\r\n        }\r\n        if (isClearingDirective) {\r\n            notifyChildrenConnectedChanged(this, isConnected);\r\n            removeDisconnectableFromParent(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the directive's Part outside the normal `update`/`render`\r\n     * lifecycle of a directive.\r\n     *\r\n     * This method should not be called synchronously from a directive's `update`\r\n     * or `render`.\r\n     *\r\n     * @param directive The directive to update\r\n     * @param value The value to set\r\n     */\r\n    setValue(value) {\r\n        if (isSingleExpression(this.__part)) {\r\n            this.__part._$setValue(value, this);\r\n        } else {\r\n            const newValues = [...this.__part._$committedValue];\r\n            newValues[this.__attributeIndex] = value;\r\n            this.__part._$setValue(newValues, this, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * User callbacks for implementing logic to release any resources/subscriptions\r\n     * that may have been retained by this directive. Since directives may also be\r\n     * re-connected, `reconnected` should also be implemented to restore the\r\n     * working state of the directive prior to the next render.\r\n     */\r\n    disconnected() { }\r\n\r\n    reconnected() { }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\n// Note, this module is not included in package exports so that it's private to\r\n// our first-party directives. If it ends up being useful, we can open it up and\r\n// export it.\r\n\r\n/**\r\n * Helper to iterate an AsyncIterable in its own closure.\r\n * @param iterable The iterable to iterate\r\n * @param callback The callback to call for each value. If the callback returns\r\n * `false`, the loop will be broken.\r\n */\r\nexport const forAwaitOf = async (iterable, callback) => {\r\n    for await (const v of iterable) {\r\n        if ((await callback(v)) === false) {\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a reference to an instance that can be disconnected and reconnected,\r\n * so that a closure over the ref (e.g. in a then function to a promise) does\r\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\r\n * be manually connected & disconnected to the backing instance.\r\n */\r\nexport class PseudoWeakRef {\r\n \r\n    constructor(ref) {\r\n        this._ref = ref;\r\n    }\r\n \r\n    /**\r\n     * Disassociates the ref with the backing instance.\r\n     */\r\n    disconnect() {\r\n        this._ref = undefined;\r\n    }\r\n \r\n    /**\r\n     * Reassociates the ref with the backing instance.\r\n     */\r\n    reconnect(ref) {\r\n        this._ref = ref;\r\n    }\r\n \r\n    /**\r\n     * Retrieves the backing instance (will be undefined when disconnected)\r\n     */\r\n    deref() {\r\n        return this._ref;\r\n    }\r\n}\r\n\r\n/**\r\n * A helper to pause and resume waiting on a condition in an async function\r\n */\r\nexport class Pauser {\r\n\r\n    constructor() {\r\n        this._promise = undefined;\r\n        this._resolve = undefined;\r\n    }\r\n\r\n    /**\r\n     * When paused, returns a promise to be awaited; when unpaused, returns\r\n     * undefined. Note that in the microtask between the pauser being resumed\r\n     * an an await of this promise resolving, the pauser could be paused again,\r\n     * hence callers should check the promise in a loop when awaiting.\r\n     * @returns A promise to be awaited when paused or undefined\r\n     */\r\n    get() {\r\n        return this._promise;\r\n    }\r\n\r\n    /**\r\n     * Creates a promise to be awaited\r\n     */\r\n    pause() {\r\n        this._promise ??= new Promise((resolve) => (this._resolve = resolve));\r\n    }\r\n\r\n    /**\r\n     * Resolves the promise which may be awaited\r\n     */\r\n    resume() {\r\n        this._resolve?.();\r\n        this._promise = this._resolve = undefined;\r\n    }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { directive } from '../directive.mjs';\r\nimport { AsyncDirective } from '../async-directive.mjs';\r\nimport { Pauser, PseudoWeakRef, forAwaitOf } from './private-async-helpers.mjs';\r\n\r\nexport class AsyncReplaceDirective extends AsyncDirective {\r\n\r\n    #weakThis;\r\n    #pauser;\r\n\r\n    constructor() {\r\n        super(...arguments);\r\n        const me = this;\r\n        me.#weakThis = new PseudoWeakRef(me);\r\n        me.#pauser = new Pauser();\r\n    }\r\n\r\n    // @ts-expect-error value not used, but we want a nice parameter for docs\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    render(value, mapper) {\r\n        return noChange;\r\n    }\r\n\r\n    update(part, [value, mapper]) {\r\n\r\n        const me = this;\r\n\r\n        // If our initial render occurs while disconnected, ensure that the pauser\r\n        // and weakThis are in the disconnected state\r\n        if (!me.isConnected) me.disconnected();\r\n\r\n        // If we've already set up this particular iterable, we don't need\r\n        // to do anything.\r\n        if (value === me.__value) return;\r\n\r\n        \r\n        const pauser = me.#pauser;\r\n        const weakThis = me.#weakThis;\r\n\r\n        let i = 0;\r\n        me.__value = value;\r\n        \r\n        // Note, the callback avoids closing over `this` so that the directive\r\n        // can be gc'ed before the promise resolves; instead `this` is retrieved\r\n        // from `weakThis`, which can break the hard reference in the closure when\r\n        // the directive disconnects\r\n        forAwaitOf(value, async (v) => {\r\n\r\n            // The while loop here handles the case that the connection state\r\n            // thrashes, causing the pauser to resume and then get re-paused\r\n            while (pauser.get()) {\r\n                await pauser.get();\r\n            }\r\n\r\n            // If the callback gets here and there is no `this`, it means that the\r\n            // directive has been disconnected and garbage collected and we don't\r\n            // need to do anything else\r\n            const ref = weakThis.deref();\r\n            if (ref !== undefined) {\r\n                // Check to make sure that value is the still the current value of\r\n                // the part, and if not bail because a new value owns this part\r\n                if (ref.__value !== value)return false;\r\n\r\n                // As a convenience, because functional-programming-style\r\n                // transforms of iterables and async iterables requires a library,\r\n                // we accept a mapper function. This is especially convenient for\r\n                // rendering a template for each item.\r\n                if (mapper !== undefined) v = mapper(v, i);\r\n                ref.commitValue(v, i);\r\n                i++;\r\n            }\r\n            return true;\r\n        });\r\n\r\n        return noChange;\r\n    }\r\n\r\n    // Override point for AsyncAppend to append rather than replace\r\n    commitValue(value, index) {\r\n        this.setValue(value);\r\n    }\r\n\r\n    disconnected() {\r\n        const me = this;\r\n        me.#weakThis.disconnect();\r\n        me.#pauser.pause();\r\n    }\r\n\r\n    reconnected() {\r\n        const me = this;\r\n        me.#weakThis.reconnect(me);\r\n        me.#pauser.resume();\r\n    }\r\n}\r\n\r\n/**\r\n * A directive that renders the items of an async iterable[1], replacing\r\n * previous values with new values, so that only one value is ever rendered\r\n * at a time. This directive may be used in any expression type.\r\n *\r\n * Async iterables are objects with a `[Symbol.asyncIterator]` method, which\r\n * returns an iterator who's `next()` method returns a Promise. When a new\r\n * value is available, the Promise resolves and the value is rendered to the\r\n * Part controlled by the directive. If another value other than this\r\n * directive has been set on the Part, the iterable will no longer be listened\r\n * to and new values won't be written to the Part.\r\n *\r\n * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\r\n *\r\n * @param value An async iterable\r\n * @param mapper An optional function that maps from (value, index) to another\r\n *     value. Useful for generating templates for each item in the iterable.\r\n */\r\nexport const asyncReplace = directive(AsyncReplaceDirective);\r\n","/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { PartType } from '../../types.mjs';\r\nimport { directive } from '../directive.mjs';\r\nimport { AsyncReplaceDirective } from './async-replace.mjs';\r\nimport { clearPart, insertPart, setChildPartValue, } from '../directive-helpers.mjs';\r\n\r\nclass AsyncAppendDirective extends AsyncReplaceDirective {\r\n\r\n    // Override AsyncReplace to narrow the allowed part type to ChildPart only\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        if (partInfo.type !== PartType.CHILD) {\r\n            throw new Error('asyncAppend can only be used in child expressions');\r\n        }\r\n    }\r\n\r\n    // Override AsyncReplace to save the part since we need to append into it\r\n    update(part, params) {\r\n        this.__childPart = part;\r\n        return super.update(part, params);\r\n    }\r\n\r\n    // Override AsyncReplace to append rather than replace\r\n    commitValue(value, index) {\r\n        // When we get the first value, clear the part. This lets the\r\n        // previous value display until we can replace it.\r\n        if (index === 0) {\r\n            clearPart(this.__childPart);\r\n        }\r\n        // Create and insert a new part and set its value to the next value\r\n        const newPart = insertPart(this.__childPart);\r\n        setChildPartValue(newPart, value);\r\n    }\r\n}\r\n\r\n/**\r\n * A directive that renders the items of an async iterable[1], appending new\r\n * values after previous values, similar to the built-in support for iterables.\r\n * This directive is usable only in child expressions.\r\n *\r\n * Async iterables are objects with a [Symbol.asyncIterator] method, which\r\n * returns an iterator who's `next()` method returns a Promise. When a new\r\n * value is available, the Promise resolves and the value is appended to the\r\n * Part controlled by the directive. If another value other than this\r\n * directive has been set on the Part, the iterable will no longer be listened\r\n * to and new values won't be written to the Part.\r\n *\r\n * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of\r\n *\r\n * @param value An async iterable\r\n * @param mapper An optional function that maps from (value, index) to another\r\n *     value. Useful for generating templates for each item in the iterable.\r\n */\r\nexport const asyncAppend = directive(AsyncAppendDirective);\r\n","import { nothing, typeSymbol } from '../../symbols.mjs';\r\nimport { DynamicHTML } from '../../dynamic/dynamic.mjs';\r\n\r\nimport { directive, Directive, } from '../directive.mjs';\r\nimport { clearPart, getCommittedValue, insertPart, isCompiledTemplateResult, isTemplateResult, setCommittedValue, } from '../directive-helpers.mjs';\r\n\r\n/**\r\n * The template strings array contents are not compatible between the two\r\n * template result types as the compiled template contains a prepared string;\r\n * only use the returned template strings array as a cache key.\r\n */\r\nconst getStringsFromTemplateResult = (result) => isCompiledTemplateResult(result) ? result[typeSymbol].h : result.strings;\r\n\r\nclass CacheDirective extends Directive {\r\n\r\n    #templateCache = new WeakMap();\r\n    #value;\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n    }\r\n\r\n    render(v) {\r\n        // Return an array of the value to induce dynamic to create a ChildPart\r\n        // for the value that we can move into the cache.\r\n        return [v];\r\n    }\r\n\r\n    update(containerPart, [v]) {\r\n\r\n        const me = this;\r\n        const valueKey = me.#key;\r\n        const vKey = isTemplateResult(v) ? getStringsFromTemplateResult(v) : null;\r\n\r\n        me.#store(containerPart, vKey, valueKey);\r\n        me.#restore(containerPart, vKey, valueKey);\r\n\r\n        return me.render(v);\r\n    }\r\n\r\n    // If the previous value is a TemplateResult and the new value is not,\r\n    // or is a different Template as the previous value, move the child part\r\n    // into the cache.\r\n    #store(containerPart, vKey) {\r\n\r\n        const me = this;\r\n        const valueKey = me.#key;\r\n\r\n        if (valueKey !== null && (vKey === null || valueKey !== vKey)) {\r\n            \r\n            // This is always an array because we return [v] in render()\r\n            const partValue = getCommittedValue(containerPart);\r\n            const childPart = partValue.pop();\r\n\r\n            let cachedContainerPart = me.#templateCache.get(valueKey);\r\n            if (cachedContainerPart === undefined) {\r\n                const fragment = document.createDocumentFragment();\r\n                cachedContainerPart = DynamicHTML.render(nothing, fragment);\r\n                cachedContainerPart.setConnected(false);\r\n                me.#templateCache.set(valueKey, cachedContainerPart);\r\n            }\r\n            \r\n            // Move into cache\r\n            setCommittedValue(cachedContainerPart, [childPart]);\r\n            insertPart(cachedContainerPart, undefined, childPart);\r\n        }\r\n\r\n    }\r\n\r\n    // If the new value is a TemplateResult and the previous value is not,\r\n    // or is a different Template as the previous value, restore the child\r\n    // part from the cache.\r\n    #restore(containerPart, vKey, valueKey) {\r\n        const me = this;\r\n        if (vKey !== null) {\r\n            if (valueKey === null || valueKey !== vKey) {\r\n                const cachedContainerPart = me.#templateCache.get(vKey);\r\n                if (cachedContainerPart !== undefined) {\r\n                    // Move the cached part back into the container part value\r\n                    const partValue = getCommittedValue(cachedContainerPart);\r\n                    const cachedPart = partValue.pop();\r\n                    // Move cached part back into DOM\r\n                    clearPart(containerPart);\r\n                    insertPart(containerPart, undefined, cachedPart);\r\n                    setCommittedValue(containerPart, [cachedPart]);\r\n                }\r\n            }\r\n            // Because vKey is non null, v must be a TemplateResult.\r\n            me.#value = v;\r\n        } else {\r\n            me.#value = undefined;\r\n        }        \r\n    }\r\n\r\n    get #key() {\r\n        const me = this;\r\n        return isTemplateResult(me.#value)\r\n            ? getStringsFromTemplateResult(me.#value)\r\n            : null;        \r\n    }\r\n}\r\n\r\n/**\r\n * Enables fast switching between multiple templates by caching the DOM nodes\r\n * and TemplateInstances produced by the templates.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * let checked = false;\r\n *\r\n * html`\r\n *   ${cache(checked ? html`input is checked` : html`input is not checked`)}\r\n * `\r\n * ```\r\n */\r\nexport const cache = directive(CacheDirective);\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\n/**\r\n * Chooses and evaluates a template function from a list based on matching\r\n * the given `value` to a case.\r\n *\r\n * Cases are structured as `[caseValue, func]`. `value` is matched to\r\n * `caseValue` by strict equality. The first match is selected. Case values\r\n * can be of any type including primitives, objects, and symbols.\r\n *\r\n * This is similar to a switch statement, but as an expression and without\r\n * fallthrough.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * render() {\r\n *   return html`\r\n *     ${choose(this.section, [\r\n *       ['home', () => html`<h1>Home</h1>`],\r\n *       ['about', () => html`<h1>About</h1>`]\r\n *     ],\r\n *     () => html`<h1>Error</h1>`)}\r\n *   `;\r\n * }\r\n * ```\r\n */\r\nexport const choose = (value, cases, defaultCase) => {\r\n    for (const c of cases) {\r\n        const caseValue = c[0];\r\n        if (caseValue === value) {\r\n            const fn = c[1];\r\n            return fn();\r\n        }\r\n    }\r\n    return defaultCase?.();\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { PartType } from '../../types.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\n\r\nclass ClassMapDirective extends Directive {\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        if (partInfo.type !== PartType.ATTRIBUTE ||\r\n            partInfo.name !== 'class' ||\r\n            partInfo.strings?.length > 2) {\r\n            throw new Error('`classMap()` can only be used in the `class` attribute ' +\r\n                'and must be the only part in the attribute.');\r\n        }\r\n    }\r\n\r\n    render(classInfo) {\r\n        // Add spaces to ensure separation from static classes\r\n        return (' ' +\r\n            Object.keys(classInfo)\r\n                .filter((key) => classInfo[key])\r\n                .join(' ') +\r\n            ' ');\r\n    }\r\n\r\n    update(part, [classInfo]) {\r\n\r\n        // Remember dynamic classes on the first render\r\n        if (this._previousClasses === undefined) {\r\n            this._previousClasses = new Set();\r\n            if (part.strings !== undefined) {\r\n                this._staticClasses = new Set(part.strings\r\n                    .join(' ')\r\n                    .split(/\\s/)\r\n                    .filter((s) => s !== ''));\r\n            }\r\n\r\n            for (const name in classInfo) {\r\n                if (classInfo[name] && !this._staticClasses?.has(name)) {\r\n                    this._previousClasses.add(name);\r\n                }\r\n            }\r\n            return this.render(classInfo);\r\n        }\r\n\r\n        const classList = part.element.classList;\r\n\r\n        // Remove old classes that no longer apply\r\n        for (const name of this._previousClasses) {\r\n            if (!(name in classInfo)) {\r\n                classList.remove(name);\r\n                this._previousClasses.delete(name);\r\n            }\r\n        }\r\n\r\n        // Add or remove classes based on their classMap value\r\n        for (const name in classInfo) {\r\n            // We explicitly want a loose truthy check of `value` because it seems\r\n            // more convenient that '' and 0 are skipped.\r\n            const value = !!classInfo[name];\r\n            if (value !== this._previousClasses.has(name) &&\r\n                !this._staticClasses?.has(name)) {\r\n                if (value) {\r\n                    classList.add(name);\r\n                    this._previousClasses.add(name);\r\n                } else {\r\n                    classList.remove(name);\r\n                    this._previousClasses.delete(name);\r\n                }\r\n            }\r\n        }\r\n        return noChange;\r\n    }\r\n}\r\n\r\n/**\r\n * A directive that applies dynamic CSS classes.\r\n *\r\n * This must be used in the `class` attribute and must be the only part used in\r\n * the attribute. It takes each property in the `classInfo` argument and adds\r\n * the property name to the element's `classList` if the property value is\r\n * truthy; if the property value is falsey, the property name is removed from\r\n * the element's `class`.\r\n *\r\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\r\n * truthy.\r\n *\r\n * @param classInfo\r\n */\r\nexport const classMap = directive(ClassMapDirective);\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\n\r\n// A sentinel that indicates guard() hasn't rendered anything yet\r\nconst initialValue = {};\r\n\r\nclass GuardDirective extends Directive {\r\n\r\n    constructor() {\r\n        super(...arguments);\r\n        this._previousValue = initialValue;\r\n    }\r\n\r\n    render(_value, f) {\r\n        return f();\r\n    }\r\n\r\n    update(_part, [value, f]) {\r\n        if (Array.isArray(value)) {\r\n            // Dirty-check arrays by item\r\n            if (Array.isArray(this._previousValue) &&\r\n                this._previousValue.length === value.length &&\r\n                value.every((v, i) => v === this._previousValue[i])) {\r\n                return noChange;\r\n            }\r\n        } else if (this._previousValue === value) {\r\n            // Dirty-check non-arrays by identity\r\n            return noChange;\r\n        }\r\n\r\n        // Copy the value if it's an array so that if it's mutated we don't forget\r\n        // what the previous values were.\r\n        this._previousValue = Array.isArray(value) ? Array.from(value) : value;\r\n        const r = this.render(value, f);\r\n        return r;\r\n    }\r\n}\r\n\r\n/**\r\n * Prevents re-render of a template function until a single value or an array of\r\n * values changes.\r\n *\r\n * Values are checked against previous values with strict equality (`===`), and\r\n * so the check won't detect nested property changes inside objects or arrays.\r\n * Arrays values have each item checked against the previous value at the same\r\n * index with strict equality. Nested arrays are also checked only by strict\r\n * equality.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * html`\r\n *   <div>\r\n *     ${guard([user.id, company.id], () => html`...`)}\r\n *   </div>\r\n * `\r\n * ```\r\n *\r\n * In this case, the template only rerenders if either `user.id` or `company.id`\r\n * changes.\r\n *\r\n * guard() is useful with immutable data patterns, by preventing expensive work\r\n * until data updates.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * html`\r\n *   <div>\r\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\r\n *   </div>\r\n * `\r\n * ```\r\n *\r\n * In this case, items are mapped over only when the array reference changes.\r\n *\r\n * @param value the value to check before re-rendering\r\n * @param f the template function\r\n */\r\nexport const guard = directive(GuardDirective);\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\nimport { nothing } from '../../symbols.mjs';\r\n\r\n/**\r\n * For AttributeParts, sets the attribute if the value is defined and removes\r\n * the attribute if the value is undefined.\r\n *\r\n * For other part types, this directive is a no-op.\r\n */\r\nexport const ifDefined = (value) => value ?? nothing;\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nexport function* join(items, joiner) {\r\n    const isFunction = typeof joiner === 'function';\r\n    if (items !== undefined) {\r\n        let i = -1;\r\n        for (const value of items) {\r\n            if (i > -1) {\r\n                yield isFunction ? joiner(i) : joiner;\r\n            }\r\n            i++;\r\n            yield value;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\nimport { nothing } from '../../symbols.mjs';\r\nimport { directive, Directive, } from '../directive.mjs';\r\nimport { setCommittedValue } from '../directive-helpers.mjs';\r\n\r\nclass Keyed extends Directive {\r\n\r\n    constructor() {\r\n        super(...arguments);\r\n        this.key = nothing;\r\n    }\r\n\r\n    render(k, v) {\r\n        this.key = k;\r\n        return v;\r\n    }\r\n\r\n    update(part, [k, v]) {\r\n        if (k !== this.key) {\r\n            // Clear the part before returning a value. The one-arg form of\r\n            // setCommittedValue sets the value to a sentinel which forces a\r\n            // commit the next render.\r\n            setCommittedValue(part);\r\n            this.key = k;\r\n        }\r\n        return v;\r\n    }\r\n}\r\n\r\n/**\r\n * Associates a renderable value with a unique key. When the key changes, the\r\n * previous DOM is removed and disposed before rendering the next value, even\r\n * if the value - such as a template - is the same.\r\n *\r\n * This is useful for forcing re-renders of stateful components, or working\r\n * with code that expects new data to generate new HTML elements, such as some\r\n * animation techniques.\r\n */\r\nexport const keyed = directive(Keyed);\r\n","/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\nimport { noChange, nothing } from '../../symbols.mjs';\r\nimport { PartType } from '../../types.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\nimport { isSingleExpression, setCommittedValue } from '../directive-helpers.mjs';\r\n\r\nclass LiveDirective extends Directive {\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        if (!(partInfo.type === PartType.PROPERTY ||\r\n            partInfo.type === PartType.ATTRIBUTE ||\r\n            partInfo.type === PartType.BOOLEAN)) {\r\n            throw new Error('The `live` directive is not allowed on child or event bindings');\r\n        }\r\n        if (!isSingleExpression(partInfo)) {\r\n            throw new Error('`live` bindings can only contain a single expression');\r\n        }\r\n    }\r\n\r\n    render(value) {\r\n        return value;\r\n    }\r\n\r\n    update(part, [value]) {\r\n\r\n        if (value === noChange || value === nothing) {\r\n            return value;\r\n        }\r\n\r\n        const element = part.element;\r\n        const name = part.name;\r\n\r\n        if (part.type === PartType.PROPERTY) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            if (value === element[name]) {\r\n                return noChange;\r\n            }\r\n        } else if (part.type === PartType.BOOLEAN) {\r\n            if (!!value === element.hasAttribute(name)) {\r\n                return noChange;\r\n            }\r\n        } else if (part.type === PartType.ATTRIBUTE) {\r\n            if (element.getAttribute(name) === String(value)) {\r\n                return noChange;\r\n            }\r\n        }\r\n\r\n        // Resets the part's value, causing its dirty-check to fail so that it\r\n        // always sets the value.\r\n        setCommittedValue(part);\r\n        return value;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks binding values against live DOM values, instead of previously bound\r\n * values, when determining whether to update the value.\r\n *\r\n * This is useful for cases where the DOM value may change from outside of\r\n * dynamic, such as with a binding to an `<input>` element's `value` property,\r\n * a content editable elements text, or to a custom element that changes it's\r\n * own properties or attributes.\r\n *\r\n * In these cases if the DOM value changes, but the value set through dynamic\r\n * bindings hasn't, dynamic won't know to update the DOM value and will leave\r\n * it alone. If this is not what you want--if you want to overwrite the DOM\r\n * value with the bound value no matter what--use the `live()` directive:\r\n *\r\n * ```js\r\n * html`<input .value=${live(x)}>`\r\n * ```\r\n *\r\n * `live()` performs a strict equality check against the live DOM value, and if\r\n * the new value is equal to the live value, does nothing. This means that\r\n * `live()` should not be used when the binding will cause a type conversion. If\r\n * you use `live()` with an attribute binding, make sure that only strings are\r\n * passed in, or the binding will update every render.\r\n */\r\nexport const live = directive(LiveDirective);\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n/**\r\n * Returns an iterable containing the result of calling `f(value)` on each\r\n * value in `items`.\r\n *\r\n * @example\r\n *\r\n * ```ts\r\n * render() {\r\n *   return html`\r\n *     <ul>\r\n *       ${map(items, (i) => html`<li>${i}</li>`)}\r\n *     </ul>\r\n *   `;\r\n * }\r\n * ```\r\n */\r\nexport function* map(items, f) {\r\n    if (items !== undefined) {\r\n        let i = 0;\r\n        for (const value of items) {\r\n            yield f(value, i++);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nexport function* range(startOrEnd, end, step = 1) {\r\n    const start = end === undefined ? 0 : startOrEnd;\r\n    end ??= startOrEnd;\r\n    for (let i = start; step > 0 ? i < end : end < i; i += step) {\r\n        yield i;\r\n    }\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { nothing } from '../../symbols.mjs';\r\nimport { directive } from '../directive.mjs';\r\nimport { AsyncDirective } from '../async-directive.mjs';\r\n\r\n/**\r\n * Creates a new Ref object, which is container for a reference to an element.\r\n */\r\nexport const createRef = () => new Ref();\r\n\r\n/**\r\n * An object that holds a ref value.\r\n */\r\nclass Ref {\r\n}\r\n\r\n// When callbacks are used for refs, this map tracks the last value the callback\r\n// was called with, for ensuring a directive doesn't clear the ref if the ref\r\n// has already been rendered to a new spot. It is double-keyed on both the\r\n// context (`options.host`) and the callback, since we auto-bind class methods\r\n// to `options.host`.\r\nconst lastElementForContextAndCallback = new WeakMap();\r\n\r\nclass RefDirective extends AsyncDirective {\r\n\r\n    render(_ref) {\r\n        return nothing;\r\n    }\r\n\r\n    update(part, [ref]) {\r\n        const refChanged = ref !== this._ref;\r\n        if (refChanged && this._ref !== undefined) {\r\n            // The ref passed to the directive has changed;\r\n            // unset the previous ref's value\r\n            this._updateRefValue(undefined);\r\n        }\r\n        if (refChanged || this._lastElementForRef !== this._element) {\r\n            // We either got a new ref or this is the first render;\r\n            // store the ref/element & update the ref value\r\n            this._ref = ref;\r\n            this._context = part.options?.host;\r\n            this._updateRefValue((this._element = part.element));\r\n        }\r\n        return nothing;\r\n    }\r\n\r\n    _updateRefValue(element) {\r\n        if (typeof this._ref === 'function') {\r\n            // If the current ref was called with a previous value, call with\r\n            // `undefined`; We do this to ensure callbacks are called in a consistent\r\n            // way regardless of whether a ref might be moving up in the tree (in\r\n            // which case it would otherwise be called with the new value before the\r\n            // previous one unsets it) and down in the tree (where it would be unset\r\n            // before being set). Note that element lookup is keyed by\r\n            // both the context and the callback, since we allow passing unbound\r\n            // functions that are called on options.host, and we want to treat\r\n            // these as unique \"instances\" of a function.\r\n            const context = this._context ?? globalThis;\r\n            let lastElementForCallback = lastElementForContextAndCallback.get(context);\r\n            if (lastElementForCallback === undefined) {\r\n                lastElementForCallback = new WeakMap();\r\n                lastElementForContextAndCallback.set(context, lastElementForCallback);\r\n            }\r\n            if (lastElementForCallback.get(this._ref) !== undefined) {\r\n                this._ref.call(this._context, undefined);\r\n            }\r\n            lastElementForCallback.set(this._ref, element);\r\n            // Call the ref with the new element value\r\n            if (element !== undefined) {\r\n                this._ref.call(this._context, element);\r\n            }\r\n        } else {\r\n            this._ref.value = element;\r\n        }\r\n    }\r\n\r\n    get _lastElementForRef() {\r\n        return typeof this._ref === 'function'\r\n            ? lastElementForContextAndCallback\r\n                .get(this._context ?? globalThis)\r\n                ?.get(this._ref)\r\n            : this._ref?.value;\r\n    }\r\n    \r\n    disconnected() {\r\n        // Only clear the box if our element is still the one in it (i.e. another\r\n        // directive instance hasn't rendered its element to it before us); that\r\n        // only happens in the event of the directive being cleared (not via manual\r\n        // disconnection)\r\n        if (this._lastElementForRef === this._element) {\r\n            this._updateRefValue(undefined);\r\n        }\r\n    }\r\n    \r\n    reconnected() {\r\n        // If we were manually disconnected, we can safely put our element back in\r\n        // the box, since no rendering could have occurred to change its state\r\n        this._updateRefValue(this._element);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets the value of a Ref object or calls a ref callback with the element it's\r\n * bound to.\r\n *\r\n * A Ref object acts as a container for a reference to an element. A ref\r\n * callback is a function that takes an element as its only argument.\r\n *\r\n * The ref directive sets the value of the Ref object or calls the ref callback\r\n * during rendering, if the referenced element changed.\r\n *\r\n * Note: If a ref callback is rendered to a different element position or is\r\n * removed in a subsequent render, it will first be called with `undefined`,\r\n * followed by another call with the new element it was rendered to (if any).\r\n *\r\n * ```js\r\n * // Using Ref object\r\n * const inputRef = createRef();\r\n * render(html`<input ${ref(inputRef)}>`, container);\r\n * inputRef.value.focus();\r\n *\r\n * // Using callback\r\n * const callback = (inputElement) => inputElement.focus();\r\n * render(html`<input ${ref(callback)}>`, container);\r\n * ```\r\n */\r\nexport const ref = directive(RefDirective);\r\n","/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { PartType } from '../../types.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\nimport { insertPart, getCommittedValue, removePart, setCommittedValue, setChildPartValue, } from '../directive-helpers.mjs';\r\n\r\n// Helper for generating a map of array item to its index over a subset\r\n// of an array (used to lazily generate `newKeyToIndexMap` and\r\n// `oldKeyToIndexMap`)\r\n\r\nconst generateMap = (list, start, end) => {\r\n    const map = new Map();\r\n    for (let i = start; i <= end; i++) {\r\n        map.set(list[i], i);\r\n    }\r\n    return map;\r\n}\r\n\r\nclass RepeatDirective extends Directive {\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        if (partInfo.type !== PartType.CHILD) {\r\n            throw new Error('repeat() can only be used in text expressions');\r\n        }\r\n    }\r\n\r\n    _getValuesAndKeys(items, keyFnOrTemplate, template) {\r\n        let keyFn;\r\n        if (template === undefined) {\r\n            template = keyFnOrTemplate;\r\n        }\r\n        else if (keyFnOrTemplate !== undefined) {\r\n            keyFn = keyFnOrTemplate;\r\n        }\r\n        const keys = [];\r\n        const values = [];\r\n        let index = 0;\r\n        for (const item of items) {\r\n            keys[index] = keyFn ? keyFn(item, index) : index;\r\n            values[index] = template(item, index);\r\n            index++;\r\n        }\r\n        return {\r\n            values,\r\n            keys,\r\n        };\r\n    }\r\n\r\n    render(items, keyFnOrTemplate, template) {\r\n        return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\r\n    }\r\n\r\n    update(containerPart, [items, keyFnOrTemplate, template]) {\r\n\r\n        // Old part & key lists are retrieved from the last update (which may\r\n        // be primed by hydration)\r\n        const oldParts = getCommittedValue(containerPart);\r\n        const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);\r\n\r\n        // We check that oldParts, the committed value, is an Array as an\r\n        // indicator that the previous value came from a repeat() call. If\r\n        // oldParts is not an Array then this is the first render and we return\r\n        // an array for dynamic's array handling to render, and remember the\r\n        // keys.\r\n        if (!Array.isArray(oldParts)) {\r\n            this._itemKeys = newKeys;\r\n            return newValues;\r\n        }\r\n\r\n        // In SSR hydration it's possible for oldParts to be an array but for us\r\n        // to not have item keys because the update() hasn't run yet. We set the\r\n        // keys to an empty array. This will cause all oldKey/newKey comparisons\r\n        // to fail and execution to fall to the last nested brach below which\r\n        // reuses the oldPart.\r\n        const oldKeys = (this._itemKeys ??= []);\r\n\r\n        // New part list will be built up as we go (either reused from\r\n        // old parts or created for new keys in this update). This is\r\n        // saved in the above cache at the end of the update.\r\n        const newParts = [];\r\n\r\n        // Maps from key to index for current and previous update; these\r\n        // are generated lazily only when needed as a performance\r\n        // optimization, since they are only required for multiple\r\n        // non-contiguous changes in the list, which are less common.\r\n        let newKeyToIndexMap;\r\n        let oldKeyToIndexMap;\r\n\r\n        // Head and tail pointers to old parts and new values\r\n        let oldHead = 0;\r\n        let oldTail = oldParts.length - 1;\r\n        let newHead = 0;\r\n        let newTail = newValues.length - 1;\r\n\r\n        // Overview of O(n) reconciliation algorithm (general approach\r\n        // based on ideas found in ivi, vue, snabbdom, etc.):\r\n        //\r\n        // * We start with the list of old parts and new values (and\r\n        //   arrays of their respective keys), head/tail pointers into\r\n        //   each, and we build up the new list of parts by updating\r\n        //   (and when needed, moving) old parts or creating new ones.\r\n        //   The initial scenario might look like this (for brevity of\r\n        //   the diagrams, the numbers in the array reflect keys\r\n        //   associated with the old parts or new values, although keys\r\n        //   and parts/values are actually stored in parallel arrays\r\n        //   indexed using the same head/tail pointers):\r\n        //\r\n        //      oldHead v                 v oldTail\r\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\r\n        //   newParts: [ ,  ,  ,  ,  ,  ,  ]\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\r\n        //                                      item order\r\n        //      newHead ^                 ^ newTail\r\n        //\r\n        // * Iterate old & new lists from both sides, updating,\r\n        //   swapping, or removing parts at the head/tail locations\r\n        //   until neither head nor tail can move.\r\n        //\r\n        // * Example below: keys at head pointers match, so update old\r\n        //   part 0 in-place (no need to move it) and record part 0 in\r\n        //   the `newParts` list. The last thing we do is advance the\r\n        //   `oldHead` and `newHead` pointers (will be reflected in the\r\n        //   next diagram).\r\n        //\r\n        //      oldHead v                 v oldTail\r\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\r\n        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\r\n        //                                      & newHead\r\n        //      newHead ^                 ^ newTail\r\n        //\r\n        // * Example below: head pointers don't match, but tail\r\n        //   pointers do, so update part 6 in place (no need to move\r\n        //   it), and record part 6 in the `newParts` list. Last,\r\n        //   advance the `oldTail` and `oldHead` pointers.\r\n        //\r\n        //         oldHead v              v oldTail\r\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\r\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\r\n        //                                      & newTail\r\n        //         newHead ^              ^ newTail\r\n        //\r\n        // * If neither head nor tail match; next check if one of the\r\n        //   old head/tail items was removed. We first need to generate\r\n        //   the reverse map of new keys to index (`newKeyToIndexMap`),\r\n        //   which is done once lazily as a performance optimization,\r\n        //   since we only hit this case if multiple non-contiguous\r\n        //   changes were made. Note that for contiguous removal\r\n        //   anywhere in the list, the head and tails would advance\r\n        //   from either end and pass each other before we get to this\r\n        //   case and removals would be handled in the final while loop\r\n        //   without needing to generate the map.\r\n        //\r\n        // * Example below: The key at `oldTail` was removed (no longer\r\n        //   in the `newKeyToIndexMap`), so remove that part from the\r\n        //   DOM and advance just the `oldTail` pointer.\r\n        //\r\n        //         oldHead v           v oldTail\r\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\r\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\r\n        //         newHead ^           ^ newTail\r\n        //\r\n        // * Once head and tail cannot move, any mismatches are due to\r\n        //   either new or moved items; if a new key is in the previous\r\n        //   \"old key to old index\" map, move the old part to the new\r\n        //   location, otherwise create and insert a new part. Note\r\n        //   that when moving an old part we null its position in the\r\n        //   oldParts array if it lies between the head and tail so we\r\n        //   know to skip it when the pointers get there.\r\n        //\r\n        // * Example below: neither head nor tail match, and neither\r\n        //   were removed; so find the `newHead` key in the\r\n        //   `oldKeyToIndexMap`, and move that old part's DOM into the\r\n        //   next head position (before `oldParts[oldHead]`). Last,\r\n        //   null the part in the `oldPart` array since it was\r\n        //   somewhere in the remaining oldParts still to be scanned\r\n        //   (between the head and tail pointers) so that we know to\r\n        //   skip that old part on future iterations.\r\n        //\r\n        //         oldHead v        v oldTail\r\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\r\n        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\r\n        //                                      newHead\r\n        //         newHead ^           ^ newTail\r\n        //\r\n        // * Note that for moves/insertions like the one above, a part\r\n        //   inserted at the head pointer is inserted before the\r\n        //   current `oldParts[oldHead]`, and a part inserted at the\r\n        //   tail pointer is inserted before `newParts[newTail+1]`. The\r\n        //   seeming asymmetry lies in the fact that new parts are\r\n        //   moved into place outside in, so to the right of the head\r\n        //   pointer are old parts, and to the right of the tail\r\n        //   pointer are new parts.\r\n        //\r\n        // * We always restart back from the top of the algorithm,\r\n        //   allowing matching and simple updates in place to\r\n        //   continue...\r\n        //\r\n        // * Example below: the head pointers once again match, so\r\n        //   simply update part 1 and record it in the `newParts`\r\n        //   array.  Last, advance both head pointers.\r\n        //\r\n        //         oldHead v        v oldTail\r\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\r\n        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\r\n        //                                      & newHead\r\n        //            newHead ^        ^ newTail\r\n        //\r\n        // * As mentioned above, items that were moved as a result of\r\n        //   being stuck (the final else clause in the code below) are\r\n        //   marked with null, so we always advance old pointers over\r\n        //   these so we're comparing the next actual old value on\r\n        //   either end.\r\n        //\r\n        // * Example below: `oldHead` is null (already placed in\r\n        //   newParts), so advance `oldHead`.\r\n        //\r\n        //            oldHead v     v oldTail\r\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\r\n        //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\r\n        //               newHead ^     ^ newTail\r\n        //\r\n        // * Note it's not critical to mark old parts as null when they\r\n        //   are moved from head to tail or tail to head, since they\r\n        //   will be outside the pointer range and never visited again.\r\n        //\r\n        // * Example below: Here the old tail key matches the new head\r\n        //   key, so the part at the `oldTail` position and move its\r\n        //   DOM to the new head position (before `oldParts[oldHead]`).\r\n        //   Last, advance `oldTail` and `newHead` pointers.\r\n        //\r\n        //               oldHead v  v oldTail\r\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\r\n        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\r\n        //                                     advance oldTail & newHead\r\n        //               newHead ^     ^ newTail\r\n        //\r\n        // * Example below: Old and new head keys match, so update the\r\n        //   old head part in place, and advance the `oldHead` and\r\n        //   `newHead` pointers.\r\n        //\r\n        //               oldHead v oldTail\r\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\r\n        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\r\n        //                                      newHead\r\n        //                  newHead ^  ^ newTail\r\n        //\r\n        // * Once the new or old pointers move past each other then all\r\n        //   we have left is additions (if old list exhausted) or\r\n        //   removals (if new list exhausted). Those are handled in the\r\n        //   final while loops at the end.\r\n        //\r\n        // * Example below: `oldHead` exceeded `oldTail`, so we're done\r\n        //   with the main loop.  Create the remaining part and insert\r\n        //   it at the new head position, and the update is complete.\r\n        //\r\n        //                   (oldHead > oldTail)\r\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\r\n        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\r\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\r\n        //                     newHead ^ newTail\r\n        //\r\n        // * Note that the order of the if/else clauses is not\r\n        //   important to the algorithm, as long as the null checks\r\n        //   come first (to ensure we're always working on valid old\r\n        //   parts) and that the final else clause comes last (since\r\n        //   that's where the expensive moves occur). The order of\r\n        //   remaining clauses is is just a simple guess at which cases\r\n        //   will be most common.\r\n        //\r\n        // * Note, we could calculate the longest\r\n        //   increasing subsequence (LIS) of old items in new position,\r\n        //   and only move those not in the LIS set. However that costs\r\n        //   O(nlogn) time and adds a bit more code, and only helps\r\n        //   make rare types of mutations require fewer moves. The\r\n        //   above handles removes, adds, reversal, swaps, and single\r\n        //   moves of contiguous items in linear time, in the minimum\r\n        //   number of moves. As the number of multiple moves where LIS\r\n        //   might help approaches a random shuffle, the LIS\r\n        //   optimization becomes less helpful, so it seems not worth\r\n        //   the code at this point. Could reconsider if a compelling\r\n        //   case arises.\r\n        while (oldHead <= oldTail && newHead <= newTail) {\r\n            if (oldParts[oldHead] === null) {\r\n                // `null` means old part at head has already been used\r\n                // below; skip\r\n                oldHead++;\r\n            } else if (oldParts[oldTail] === null) {\r\n                // `null` means old part at tail has already been used\r\n                // below; skip\r\n                oldTail--;\r\n            } else if (oldKeys[oldHead] === newKeys[newHead]) {\r\n                // Old head matches new head; update in place\r\n                newParts[newHead] = setChildPartValue(oldParts[oldHead], newValues[newHead]);\r\n                oldHead++;\r\n                newHead++;\r\n            } else if (oldKeys[oldTail] === newKeys[newTail]) {\r\n                // Old tail matches new tail; update in place\r\n                newParts[newTail] = setChildPartValue(oldParts[oldTail], newValues[newTail]);\r\n                oldTail--;\r\n                newTail--;\r\n            } else if (oldKeys[oldHead] === newKeys[newTail]) {\r\n                // Old head matches new tail; update and move to new tail\r\n                newParts[newTail] = setChildPartValue(oldParts[oldHead], newValues[newTail]);\r\n                insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);\r\n                oldHead++;\r\n                newTail--;\r\n            } else if (oldKeys[oldTail] === newKeys[newHead]) {\r\n                // Old tail matches new head; update and move to new head\r\n                newParts[newHead] = setChildPartValue(oldParts[oldTail], newValues[newHead]);\r\n                insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);\r\n                oldTail--;\r\n                newHead++;\r\n            } else {\r\n              \r\n                if (newKeyToIndexMap === undefined) {\r\n                    // Lazily generate key-to-index maps, used for removals &\r\n                    // moves below\r\n                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\r\n                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\r\n                }\r\n              \r\n                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\r\n                    // Old head is no longer in new list; remove\r\n                    removePart(oldParts[oldHead]);\r\n                    oldHead++;\r\n                } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\r\n                    // Old tail is no longer in new list; remove\r\n                    removePart(oldParts[oldTail]);\r\n                    oldTail--;\r\n                } else {\r\n                    // Any mismatches at this point are due to additions or\r\n                    // moves; see if we have an old part we can reuse and move\r\n                    // into place\r\n                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\r\n                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\r\n                    if (oldPart === null) {\r\n                        // No old part for this value; create a new one and\r\n                        // insert it\r\n                        const newPart = insertPart(containerPart, oldParts[oldHead]);\r\n                        setChildPartValue(newPart, newValues[newHead]);\r\n                        newParts[newHead] = newPart;\r\n                    } else {\r\n                        // Reuse old part\r\n                        newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\r\n                        insertPart(containerPart, oldParts[oldHead], oldPart);\r\n                        // This marks the old part as having been used, so that\r\n                        // it will be skipped in the first two checks above\r\n                        oldParts[oldIndex] = null;\r\n                    }\r\n                    newHead++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add parts for any remaining new values\r\n        while (newHead <= newTail) {\r\n            // For all remaining additions, we insert before last new\r\n            // tail, since old pointers are no longer valid\r\n            const newPart = insertPart(containerPart, newParts[newTail + 1]);\r\n            setChildPartValue(newPart, newValues[newHead]);\r\n            newParts[newHead++] = newPart;\r\n        }\r\n        \r\n        // Remove any remaining unused old parts\r\n        while (oldHead <= oldTail) {\r\n            const oldPart = oldParts[oldHead++];\r\n            if (oldPart !== null) {\r\n                removePart(oldPart);\r\n            }\r\n        }\r\n        \r\n        // Save order of new parts for next round\r\n        this._itemKeys = newKeys;\r\n        // Directly set part value, bypassing it's dirty-checking\r\n        setCommittedValue(containerPart, newParts);\r\n        return noChange;\r\n    }\r\n}\r\n\r\n/**\r\n * A directive that repeats a series of values (usually `TemplateResults`)\r\n * generated from an iterable, and updates those items efficiently when the\r\n * iterable changes based on user-provided `keys` associated with each item.\r\n *\r\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\r\n * meaning previous DOM for a given key is moved into the new position if\r\n * needed, and DOM will never be reused with values for different keys (new DOM\r\n * will always be created for new keys). This is generally the most efficient\r\n * way to use `repeat` since it performs minimum unnecessary work for insertions\r\n * and removals.\r\n *\r\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\r\n *\r\n * ```js\r\n * html`\r\n *   <ol>\r\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\r\n *       return html`<li>${index}: ${item.name}</li>`;\r\n *     })}\r\n *   </ol>\r\n * `\r\n * ```\r\n *\r\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\r\n * given call to `repeat`. The behavior when two or more items have the same key\r\n * is undefined.\r\n *\r\n * If no `keyFn` is provided, this directive will perform similar to mapping\r\n * items to values, and DOM will be reused against potentially different items.\r\n */\r\nexport const repeat = directive(RepeatDirective);\r\n","/**\r\n * @license\r\n * Copyright 2018 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { PartType } from '../../types.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\n\r\nconst important = 'important';\r\n\r\n// The leading space is important\r\nconst importantFlag = ' !' + important;\r\n\r\n// How many characters to remove from a value, as a negative number\r\nconst flagTrim = 0 - importantFlag.length;\r\n\r\nclass StyleMapDirective extends Directive {\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        if (partInfo.type !== PartType.ATTRIBUTE ||\r\n            partInfo.name !== 'style' ||\r\n            partInfo.strings?.length > 2) {\r\n            throw new Error('The `styleMap` directive must be used in the `style` attribute ' +\r\n                'and must be the only part in the attribute.');\r\n        }\r\n    }\r\n\r\n    render(styleInfo) {\r\n        return Object.keys(styleInfo).reduce((style, prop) => {\r\n            const value = styleInfo[prop];\r\n            if (value == null) {\r\n                return style;\r\n            }\r\n            // Convert property names from camel-case to dash-case, i.e.:\r\n            //  `backgroundColor` -> `background-color`\r\n            // Vendor-prefixed names need an extra `-` appended to front:\r\n            //  `webkitAppearance` -> `-webkit-appearance`\r\n            // Exception is any property name containing a dash, including\r\n            // custom properties; we assume these are already dash-cased i.e.:\r\n            //  `--my-button-color` --> `--my-button-color`\r\n            prop = prop.includes('-')\r\n                ? prop\r\n                : prop\r\n                    .replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, '-$&')\r\n                    .toLowerCase();\r\n            return style + `${prop}:${value};`;\r\n        }, '');\r\n    }\r\n\r\n    update(part, [styleInfo]) {\r\n\r\n        const { style } = part.element;\r\n\r\n        if (this._previousStyleProperties === undefined) {\r\n            this._previousStyleProperties = new Set(Object.keys(styleInfo));\r\n            return this.render(styleInfo);\r\n        }\r\n\r\n        // Remove old properties that no longer exist in styleInfo\r\n        for (const name of this._previousStyleProperties) {\r\n            // If the name isn't in styleInfo or it's null/undefined\r\n            if (styleInfo[name] == null) {\r\n                this._previousStyleProperties.delete(name);\r\n                if (name.includes('-')) {\r\n                    style.removeProperty(name);\r\n                } else {\r\n                    style[name] = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add or update properties\r\n        for (const name in styleInfo) {\r\n\r\n            const value = styleInfo[name];\r\n\r\n            if (value != null) {\r\n                this._previousStyleProperties.add(name);\r\n                const isImportant = typeof value === 'string' && value.endsWith(importantFlag);\r\n                if (name.includes('-') || isImportant) {\r\n                    style.setProperty(name, isImportant\r\n                        ? value.slice(0, flagTrim)\r\n                        : value, isImportant ? important : '');\r\n                } else {\r\n                    style[name] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return noChange;\r\n    }\r\n}\r\n\r\n/**\r\n * A directive that applies CSS properties to an element.\r\n *\r\n * `styleMap` can only be used in the `style` attribute and must be the only\r\n * expression in the attribute. It takes the property names in the\r\n * {@link StyleInfo styleInfo} object and adds the properties to the inline\r\n * style of the element.\r\n *\r\n * Property names with dashes (`-`) are assumed to be valid CSS\r\n * property names and set on the element's style object using `setProperty()`.\r\n * Names without dashes are assumed to be camelCased JavaScript property names\r\n * and set on the element's style object using property assignment, allowing the\r\n * style object to translate JavaScript-style names to CSS property names.\r\n *\r\n * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':\r\n * '0'})` sets the `background-color`, `border-top` and `--size` properties.\r\n *\r\n * @param styleInfo\r\n * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}\r\n */\r\nexport const styleMap = directive(StyleMapDirective);\r\n","/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { PartType } from '../../types.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\n\r\nclass TemplateContentDirective extends Directive {\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        if (partInfo.type !== PartType.CHILD) {\r\n            throw new Error('templateContent can only be used in child bindings');\r\n        }\r\n    }\r\n\r\n    render(template) {\r\n        if (this._previousTemplate === template) {\r\n            return noChange;\r\n        }\r\n        this._previousTemplate = template;\r\n        return document.importNode(template.content, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Renders the content of a template element as HTML.\r\n *\r\n * Note, the template should be developer controlled and not user controlled.\r\n * Rendering a user-controlled template with this directive\r\n * could lead to cross-site-scripting vulnerabilities.\r\n */\r\nexport const templateContent = directive(TemplateContentDirective);\r\n","\r\nimport { noChange, nothing, typeSymbol } from '../../symbols.mjs';\r\nimport { PartType, ResultType } from '../../types.mjs';\r\nimport { directive, Directive } from '../directive.mjs';\r\n\r\nexport class UnsafeHTMLDirective extends Directive {\r\n\r\n    constructor(partInfo) {\r\n        super(partInfo);\r\n        this._value = nothing;\r\n        if (partInfo.type !== PartType.CHILD) {\r\n            throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);\r\n        }\r\n    }\r\n\r\n    render(value) {\r\n        if (value === nothing || value == null) {\r\n            this._templateResult = undefined;\r\n            return (this._value = value);\r\n        }\r\n        if (value === noChange) {\r\n            return value;\r\n        }\r\n        if (typeof value != 'string') {\r\n            throw new Error(`${this.constructor.directiveName}() called with a non-string value`);\r\n        }\r\n        if (value === this._value) {\r\n            return this._templateResult;\r\n        }\r\n        this._value = value;\r\n        const strings = [value];\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        strings.raw = strings;\r\n        // WARNING: impersonating a TemplateResult like this is extremely\r\n        // dangerous. Third-party directives should not do this.\r\n        return (this._templateResult = {\r\n            // Cast to a known set of integers that satisfy ResultType so that we\r\n            // don't have to export ResultType and possibly encourage this pattern.\r\n            // This property needs to remain unminified.\r\n            [typeSymbol]: this.constructor.resultType,\r\n            strings,\r\n            values: [],\r\n        });\r\n    }\r\n}\r\n\r\nUnsafeHTMLDirective.directiveName = 'unsafeHTML';\r\nUnsafeHTMLDirective.resultType = ResultType.HTML;\r\n\r\n/**\r\n * Renders the result as HTML, rather than text.\r\n *\r\n * The values `undefined`, `null`, and `nothing`, will all result in no content\r\n * (empty string) being rendered.\r\n *\r\n * Note, this is unsafe to use with any user-provided input that hasn't been\r\n * sanitized or escaped, as it may lead to cross-site-scripting\r\n * vulnerabilities.\r\n */\r\nexport const unsafeHTML = directive(UnsafeHTMLDirective);\r\n","/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\n\r\nimport { directive } from '../directive.mjs';\r\nimport { UnsafeHTMLDirective } from './unsafe-html.mjs';\r\n\r\nconst SVG = 2;\r\n\r\nclass UnsafeSVGDirective extends UnsafeHTMLDirective {}\r\n\r\nUnsafeSVGDirective.directiveName = 'unsafeSVG';\r\nUnsafeSVGDirective.resultType = SVG;\r\n\r\n/**\r\n * Renders the result as SVG, rather than text.\r\n *\r\n * The values `undefined`, `null`, and `nothing`, will all result in no content\r\n * (empty string) being rendered.\r\n *\r\n * Note, this is unsafe to use with any user-provided input that hasn't been\r\n * sanitized or escaped, as it may lead to cross-site-scripting\r\n * vulnerabilities.\r\n */\r\nexport const unsafeSVG = directive(UnsafeSVGDirective);\r\n","/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nimport { noChange } from '../../symbols.mjs';\r\nimport { isPrimitive } from '../../shared.mjs';\r\nimport { directive} from '../directive.mjs';\r\nimport { AsyncDirective } from '../async-directive.mjs';\r\nimport { Pauser, PseudoWeakRef } from './private-async-helpers.mjs';\r\n\r\nconst isPromise = (x) => {\r\n    return !isPrimitive(x) && typeof x.then === 'function';\r\n}\r\n\r\n// Effectively infinity, but a SMI.\r\nconst _infinity = 0x3fffffff;\r\n\r\nexport class UntilDirective extends AsyncDirective {\r\n\r\n    constructor() {\r\n        super(...arguments);\r\n        this.__lastRenderedIndex = _infinity;\r\n        this.__values = [];\r\n        this.__weakThis = new PseudoWeakRef(this);\r\n        this.__pauser = new Pauser();\r\n    }\r\n\r\n    render(...args) {\r\n        return args.find((x) => !isPromise(x)) ?? noChange;\r\n    }\r\n\r\n    update(_part, args) {\r\n\r\n        const previousValues = this.__values;\r\n        let previousLength = previousValues.length;\r\n        this.__values = args;\r\n        const weakThis = this.__weakThis;\r\n        const pauser = this.__pauser;\r\n        // If our initial render occurs while disconnected, ensure that the pauser\r\n\r\n        // and weakThis are in the disconnected state\r\n        if (!this.isConnected) {\r\n            this.disconnected();\r\n        }\r\n\r\n        for (let i = 0; i < args.length; i++) {\r\n\r\n            // If we've rendered a higher-priority value already, stop.\r\n            if (i > this.__lastRenderedIndex) {\r\n                break;\r\n            }\r\n\r\n            const value = args[i];\r\n\r\n            // Render non-Promise values immediately\r\n            if (!isPromise(value)) {\r\n                this.__lastRenderedIndex = i;\r\n                // Since a lower-priority value will never overwrite a higher-priority\r\n                // synchronous value, we can stop processing now.\r\n                return value;\r\n            }\r\n\r\n            // If this is a Promise we've already handled, skip it.\r\n            if (i < previousLength && value === previousValues[i]) {\r\n                continue;\r\n            }\r\n\r\n            // We have a Promise that we haven't seen before, so priorities may have\r\n            // changed. Forget what we rendered before.\r\n            this.__lastRenderedIndex = _infinity;\r\n            previousLength = 0;\r\n\r\n            // Note, the callback avoids closing over `this` so that the directive\r\n            // can be gc'ed before the promise resolves; instead `this` is retrieved\r\n            // from `weakThis`, which can break the hard reference in the closure when\r\n            // the directive disconnects\r\n            Promise.resolve(value).then(async (result) => {\r\n\r\n                // If we're disconnected, wait until we're (maybe) reconnected\r\n                // The while loop here handles the case that the connection state\r\n                // thrashes, causing the pauser to resume and then get re-paused\r\n                while (pauser.get()) {\r\n                    await pauser.get();\r\n                }\r\n\r\n                // If the callback gets here and there is no `this`, it means that the\r\n                // directive has been disconnected and garbage collected and we don't\r\n                // need to do anything else\r\n                const _this = weakThis.deref();\r\n\r\n                if (_this !== undefined) {\r\n\r\n                    const index = _this.__values.indexOf(value);\r\n\r\n                    // If state.values doesn't contain the value, we've re-rendered without\r\n                    // the value, so don't render it. Then, only render if the value is\r\n                    // higher-priority than what's already been rendered.\r\n                    if (index > -1 && index < _this.__lastRenderedIndex) {\r\n                        _this.__lastRenderedIndex = index;\r\n                        _this.setValue(result);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        return noChange;\r\n    }\r\n\r\n    disconnected() {\r\n        this.__weakThis.disconnect();\r\n        this.__pauser.pause();\r\n    }\r\n\r\n    reconnected() {\r\n        this.__weakThis.reconnect(this);\r\n        this.__pauser.resume();\r\n    }\r\n}\r\n\r\n/**\r\n * Renders one of a series of values, including Promises, to a Part.\r\n *\r\n * Values are rendered in priority order, with the first argument having the\r\n * highest priority and the last argument having the lowest priority. If a\r\n * value is a Promise, low-priority values will be rendered until it resolves.\r\n *\r\n * The priority of values can be used to create placeholder content for async\r\n * data. For example, a Promise with pending content can be the first,\r\n * highest-priority, argument, and a non_promise loading indicator template can\r\n * be used as the second, lower-priority, argument. The loading indicator will\r\n * render immediately, and the primary content will render when the Promise\r\n * resolves.\r\n *\r\n * Example:\r\n *\r\n * ```js\r\n * const content = fetch('./content.txt').then(r => r.text());\r\n * html`${until(content, html`<span>Loading...</span>`)}`\r\n * ```\r\n */\r\nexport const until = directive(UntilDirective);\r\n\r\n/**\r\n * The type of the class that powers this directive. Necessary for naming the\r\n * directive's return type.\r\n */\r\n// export type {UntilDirective};\r\n","/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n * SPDX-License-Identifier: BSD-3-Clause\r\n */\r\nexport function when(condition, trueCase, falseCase) {\r\n    return condition ? trueCase(condition) : falseCase?.(condition);\r\n}\r\n","\r\n\r\nconst trustedTypes = globalThis.trustedTypes;\r\n\r\nconst emptyStringForBooleanAttribute = trustedTypes\r\n    ? trustedTypes.emptyScript\r\n    : '';\r\n\r\nexport class AttributeConverter {\r\n\r\n    toAttribute(value, type)  {\r\n        switch (type) {\r\n          case Boolean:\r\n            value = value ? emptyStringForBooleanAttribute : null;\r\n            break;\r\n          case Object:\r\n          case Array:\r\n            value = value == null ? value : JSON.stringify(value);\r\n            break;\r\n        }\r\n        return value;\r\n      }\r\n    \r\n      fromAttribute(value = null, type) {\r\n        let fromValue = value;\r\n        switch (type) {\r\n          case Boolean:\r\n            fromValue = value !== null;\r\n            break;\r\n          case Number:\r\n            fromValue = value === null ? null : Number(value);\r\n            break;\r\n          case Object:\r\n          case Array:\r\n            try {\r\n              fromValue = JSON.parse(value);\r\n            } catch (e) {\r\n              fromValue = null;\r\n            }\r\n            break;\r\n        }\r\n        return fromValue;\r\n      }\r\n\r\n}","/**\r\n * A Reactive Controller is an object that enables sub-component code\r\n * organization and reuse by aggregating the state, behavior, and lifecycle\r\n * hooks related to a single feature.\r\n *\r\n * Controllers are added to a host component, or other object that implements\r\n * the `ReactiveControllerHost` interface, via the `addController()` method.\r\n * They can hook their host components's lifecycle by implementing one or more\r\n * of the lifecycle callbacks, or initiate an update of the host component by\r\n * calling `requestUpdate()` on the host.\r\n */\r\nexport class ReactiveController {\r\n\r\n    /**\r\n    * Called when the host is connected to the component tree. For custom\r\n    * element hosts, this corresponds to the `connectedCallback()` lifecycle,\r\n    * which is only called when the component is connected to the document.\r\n    */\r\n    hostConnected() { }\r\n\r\n    /**\r\n     * Called when the host is disconnected from the component tree. For custom\r\n     * element hosts, this corresponds to the `disconnectedCallback()` lifecycle,\r\n     * which is called the host or an ancestor component is disconnected from the\r\n     * document.\r\n     */\r\n    hostDisconnected() { }\r\n\r\n    /**\r\n     * Called during the client-side host update, just before the host calls\r\n     * its own update.\r\n     *\r\n     * Code in `update()` can depend on the DOM as it is not called in\r\n     * server-side rendering.\r\n     */\r\n    hostUpdate() { }\r\n\r\n    /**\r\n     * Called after a host update, just before the host calls firstUpdated and\r\n     * updated. It is not called in server-side rendering.\r\n     *\r\n     */\r\n    hostUpdated() { }\r\n}","/**\r\n * An object that can host Reactive Controllers and call their lifecycle\r\n * callbacks.\r\n */\r\nexport class ReactiveControllerHost {\r\n\r\n    /**\r\n     * Adds a controller to the host, which sets up the controller's lifecycle\r\n     * methods to be called with the host's lifecycle.\r\n     * @param {ReactiveController} controller\r\n     */\r\n    addController(controller) { }\r\n\r\n    /**\r\n     * Removes a controller from the host.\r\n     * @param {ReactiveController} controller\r\n     */\r\n    removeController(controller) { }\r\n\r\n    /**\r\n     * Requests a host update which is processed asynchronously. The update can\r\n     * be waited on via the `updateComplete` property.\r\n     */\r\n    requestUpdate() { }\r\n\r\n    /**\r\n     * Returns a Promise that resolves when the host has completed updating.\r\n     * The Promise value is a boolean that is `true` if the element completed the\r\n     * update without triggering another update. The Promise result is `false` if\r\n     * a property was set inside `updated()`. If the Promise is rejected, an\r\n     * exception was thrown during the update.\r\n     *\r\n     * @return A promise of a boolean that indicates if the update resolved\r\n     *     without triggering another update.\r\n     */\r\n    async updateComplete() { };\r\n}","\r\nexport const supportsAdoptingStyleSheets = globalThis.ShadowRoot && 'adoptedStyleSheets' in Document.prototype && 'replace' in CSSStyleSheet.prototype;\r\nexport const constructionToken = Symbol();\r\nexport const symbolResult = Symbol('_$cssResult$');\r\n","import { supportsAdoptingStyleSheets, constructionToken, symbolResult } from './shared.mjs';\r\n\r\n/**\r\n * A container for a string of CSS text, that may be used to create a CSSStyleSheet.\r\n*\r\n* CSSResult is the return value of `css`-tagged template literals and\r\n* `unsafeCSS()`. In order to ensure that CSSResults are only created via the\r\n* `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.\r\n*/\r\nexport class CSSResult {\r\n\r\n    static #cssTagCache = new WeakMap();\r\n    #styleSheet;\r\n    #strings;\r\n\r\n    constructor(cssText, strings, safeToken) {\r\n        const me = this;\r\n        me[symbolResult] = true;\r\n        if (safeToken !== constructionToken) throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');\r\n        me.cssText = cssText;\r\n        me.#strings = strings;\r\n    }\r\n\r\n    // This is a getter so that it's lazy. In practice, this means stylesheets\r\n    // are not created until the first element instance is made.\r\n    get styleSheet() {\r\n\r\n        const me = this;\r\n\r\n        // If `supportsAdoptingStyleSheets` is true then we assume CSSStyleSheet is\r\n        // constructable.\r\n        let styleSheet = me.#styleSheet;\r\n        const strings = me.#strings;\r\n\r\n        if (supportsAdoptingStyleSheets && styleSheet === undefined) {\r\n\r\n            const cacheable = me.#cacheable;\r\n            if (cacheable) styleSheet = CSSResult.#read(strings);\r\n\r\n            if (styleSheet === undefined) {\r\n                (this.#styleSheet = styleSheet = new CSSStyleSheet()).replaceSync(me.cssText);\r\n                if (cacheable) CSSResult.#write(strings, styleSheet);\r\n            }\r\n        }\r\n\r\n        return styleSheet;\r\n    }\r\n\r\n    toString() {\r\n        return this.cssText;\r\n    }\r\n\r\n    get #cacheable() {\r\n        return this.#strings !== undefined && this.#strings.length === 1;\r\n    }\r\n\r\n    static #read(key) {\r\n        return CSSResult.#cssTagCache.get(key);\r\n    }\r\n\r\n    static #write(key, value) {\r\n        CSSResult.#cssTagCache.set(key, value);\r\n    }\r\n}\r\n","import { CSSResult } from \"./CSSResult.mjs\";\r\nimport { supportsAdoptingStyleSheets, constructionToken, symbolResult } from './shared.mjs';\r\n\r\nexport class CSS {\r\n\r\n    static #textFromCSSResult(value) {\r\n        // This property needs to remain unminified.\r\n        if (value[symbolResult] === true) {\r\n            return value.cssText;\r\n        } else if (typeof value === 'number') {\r\n            return value;\r\n        } else {\r\n            throw new Error(`Value passed to 'css' function must be a 'css' function result: ` +\r\n                `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +\r\n                `to ensure page security.`);\r\n        }\r\n    }\r\n\r\n    static #cssResultFromStyleSheet = (sheet) => {\r\n        let cssText = '';\r\n        for (const rule of sheet.cssRules) {\r\n            cssText += rule.cssText;\r\n        }\r\n        return CSS.unsafeCSS(cssText);\r\n    }\r\n\r\n    static #toString(value) {\r\n        return typeof value === 'string' ? value : String(value);\r\n    }\r\n\r\n    static #createStyle(value) {\r\n        const style = document.createElement('style');\r\n        const nonce = globalThis['vlitNonce'];\r\n        if (nonce !== undefined) style.setAttribute('nonce', nonce);\r\n        style.textContent = value;\r\n        return style;\r\n    }\r\n\r\n    /**\r\n     * Wrap a value for interpolation in a css tagged template literal.\r\n     *\r\n     * This is unsafe because untrusted CSS text can be used to phone home\r\n     * or exfiltrate data to an attacker controlled site. Take care to only use\r\n     * this with trusted input.\r\n     */\r\n    static unsafeCSS(value) {\r\n        return new CSSResult(CSS.#toString(value), undefined, constructionToken);\r\n    }\r\n\r\n    /**\r\n     * A template literal tag which can be used with LitElement's\r\n     * {@linkcode ReactiveElement.styles} property to set element styles.\r\n     *\r\n     * For security reasons, only literal string values and number may be used in\r\n     * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}\r\n     * may be used inside an expression.\r\n     */\r\n    static css(strings, ...values) {\r\n        const cssText = strings.length === 1\r\n            ? strings[0]\r\n            : values.reduce((acc, v, idx) => acc + CSS.#textFromCSSResult(v) + strings[idx + 1], strings[0]);\r\n        return new CSSResult(cssText, strings, constructionToken);\r\n    }\r\n\r\n    /**\r\n     * Applies the given styles to a `shadowRoot`. When Shadow DOM is\r\n     * available but `adoptedStyleSheets` is not, styles are appended to the\r\n     * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\r\n     * Note, when shimming is used, any styles that are subsequently placed into\r\n     * the shadowRoot should be placed *before* any shimmed adopted styles. This\r\n     * will match spec behavior that gives adopted sheets precedence over styles in\r\n     * shadowRoot.\r\n     */\r\n    static adoptStyles(renderRoot, styles) {\r\n        if (supportsAdoptingStyleSheets) {\r\n            renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);\r\n        } else {\r\n            styles.map((s) => CSS.#createStyle(s.cssText)).forEach(style => renderRoot.appendChild(style));\r\n        }\r\n    }\r\n\r\n    static getCompatibleStyle(s) {\r\n        if (supportsAdoptingStyleSheets) return s;\r\n        return s instanceof CSSStyleSheet ? CSS.#cssResultFromStyleSheet(s) : s\r\n    }\r\n\r\n}\r\n\r\n// for Lit 3.0 compatibility\r\nexport const css =  CSS.css;\r\nexport const unsafeCSS = CSS.unsafeCSS;\r\nexport const adoptStyles = CSS.adoptStyles;","\r\nimport { ReactiveController } from './ReactiveController.mjs';\r\nimport { AttributeConverter } from './AttributeConverter.mjs';\r\nimport { CSS } from './css/index.mjs';\r\n\r\nconst defaultConverter = new AttributeConverter();\r\nexport const notEqual = (val, old) => !Object.is(val, old);\r\n\r\nconst defaultPropertyDeclaration = {\r\n    attribute: true,\r\n    reflect: false,\r\n    type: String,\r\n    converter: defaultConverter,\r\n    hasChanged: notEqual,\r\n}\r\n\r\nconst attributeToPropertyMap = Symbol('attributeToPropertyMap');\r\nconst prepare = Symbol('prepare');\r\n\r\nconst prepareFn = function () {\r\n    const me = this;\r\n    if (Object.hasOwn(me, 'elementProperties')) return;\r\n    const superCtor = Object.getPrototypeOf(me);\r\n    if (typeof superCtor.finalize === 'function') superCtor.finalize();\r\n    me.elementProperties = new Map(superCtor.elementProperties);\r\n}\r\n\r\nconst attributeNameForProperty = (name, options) => {\r\n    const attribute = options.attribute;\r\n    return attribute === false\r\n        ? undefined\r\n        : typeof attribute === 'string'\r\n            ? attribute\r\n            : typeof name === 'string'\r\n                ? name.toLowerCase()\r\n                : undefined;\r\n}\r\n\r\nSymbol.metadata ??= Symbol('metadata');\r\n\r\nglobalThis.ReactivePropertyMetadata ??= new WeakMap();\r\n\r\n/**\r\n * Reactive WebComponent based on Google ltd. Lit ReactiveElement\r\n */\r\nexport class ReactiveElement extends HTMLElement {\r\n\r\n    static shadowRootOptions = { mode: 'open' };\r\n\r\n    static initializers = undefined;\r\n    static elementProperties = undefined;\r\n    static elementStyles = [];\r\n\r\n    // user defiend \r\n    static properties = {};\r\n    static styles = undefined;\r\n\r\n    static finalized = false;\r\n\r\n    #reflectingProperties = undefined;\r\n    #instanceProperties = undefined;\r\n\r\n    #controllers = undefined;\r\n    #updatePromise = undefined;\r\n    #changedProperties = undefined;\r\n    #reflectingProperty = undefined;\r\n    #renderRoot = undefined;\r\n\r\n    #hasUpdated = false;\r\n    #isUpdatePending = false;\r\n\r\n\r\n    /**\r\n     * Returns a list of attributes corresponding to the registered properties.\r\n    */\r\n    static get observedAttributes() {\r\n        Object.defineProperty(ReactiveElement.__proto__, prepare, { value: prepareFn });\r\n        const me = this;\r\n        me.finalize();\r\n        return me[attributeToPropertyMap] && [...me[attributeToPropertyMap].keys()];\r\n    }\r\n\r\n    static addInitializer(initializer) {\r\n        const me = this;\r\n        me[prepare]();\r\n        me.initializers ??= [].push(initializer);\r\n    }\r\n\r\n    static finalize() {\r\n        const me = this;\r\n        if (Object.hasOwn(me, 'finalized')) return;\r\n        me.finalized = true;\r\n        me[prepare]();\r\n\r\n        if (Object.hasOwn(me, 'properties')) {\r\n            const props = me.properties;\r\n            const propKeys = [\r\n                ...Object.getOwnPropertyNames(props),\r\n                ...Object.getOwnPropertySymbols(props),\r\n            ];\r\n            for (const p of propKeys) {\r\n                me.createProperty(p, props[p]);\r\n            }\r\n        }\r\n\r\n        const metadata = me[Symbol.metadata];\r\n        if (metadata !== null) {\r\n            const properties = ReactivePropertyMetadata.get(metadata);\r\n            if (properties !== undefined) {\r\n                for (const [p, options] of properties) {\r\n                    me.elementProperties.set(p, options);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // Create the attribute-to-property map\r\n        me[attributeToPropertyMap] = new Map();\r\n        for (const [p, options] of me.elementProperties) {\r\n            const attr = attributeNameForProperty(p, options);\r\n            if (attr !== undefined) {\r\n                me[attributeToPropertyMap].set(attr, p);\r\n            }\r\n        }\r\n\r\n        me.elementStyles = me.finalizeStyles(me.styles);\r\n    }\r\n\r\n    static finalizeStyles(styles) {\r\n        const elementStyles = [];\r\n        if (Array.isArray(styles)) {\r\n            const set = new Set(styles.flat(Infinity).reverse());\r\n            set.forEach(s => elementStyles.unshift(CSS.getCompatibleStyle(s)));\r\n        } else if (styles !== undefined) {\r\n            elementStyles.push(CSS.getCompatibleStyle(styles));\r\n        }\r\n        return elementStyles;\r\n    }\r\n\r\n    static createProperty(name, options) {\r\n        const me = this;\r\n        if (options.state) options.attribute = false;\r\n        me[prepare]();\r\n        me.elementProperties.set(name, options);\r\n        if (!options.noAccessor) {\r\n            const key = Symbol();\r\n            const descriptor = me.getPropertyDescriptor(name, key, options);\r\n            if (descriptor !== undefined) {\r\n                Object.defineProperty(me.prototype, name, descriptor);\r\n            }\r\n        }\r\n    }\r\n\r\n    static getPropertyDescriptor(name, key, options) {\r\n        const { get, set } = Object.getOwnPropertyDescriptor(this.prototype, name) ?? {\r\n            get() {\r\n                return this[key];\r\n            },\r\n            set(v) {\r\n                this[key] = v;\r\n            },\r\n        }\r\n        return {\r\n            get() {\r\n                return get?.call(this);\r\n            },\r\n            set(value) {\r\n                const me = this;\r\n                const oldValue = get?.call(me);\r\n                set?.call(me, value);\r\n                me.requestUpdate(name, oldValue, options);\r\n            },\r\n            configurable: true,\r\n            enumerable: true,\r\n        }\r\n    }\r\n\r\n    static getPropertyOptions(name) {\r\n        return this.elementProperties.get(name) ?? defaultPropertyDeclaration;\r\n    }\r\n\r\n    constructor() {\r\n        super();\r\n        this.#initialize();\r\n    }\r\n\r\n    connectedCallback() {\r\n        const me = this;\r\n        me.#renderRoot ??= me.createRenderRoot();\r\n        me.enableUpdating(true);\r\n        me.#controllers?.forEach((c) => c.hostConnected?.());\r\n    }\r\n\r\n    disconnectedCallback() {\r\n        this.#controllers?.forEach((c) => c.hostDisconnected?.());\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n        this.#attributeToProperty(name, newValue);\r\n    }\r\n\r\n    // ******************************\r\n    // PUBLIC GETTERS\r\n    // ******************************\r\n\r\n    get hasUpdated() { return this.#hasUpdated; }\r\n    get isUpdatePending() { return this.#isUpdatePending; }\r\n    get renderRoot() { return this.#renderRoot; }\r\n\r\n    // ******************************\r\n    // PROTECTED FUNCTIONS \r\n    // ******************************\r\n\r\n    addController(controller) {\r\n        // if (!(controller instanceof ReactiveController)) throw new Error('Argument not instance of ReactiveController');\r\n        const me = this;\r\n        (me.#controllers ??= new Set()).add(controller);\r\n        if (me.renderRoot !== undefined && me.isConnected) {\r\n            controller.hostConnected?.();\r\n        }\r\n    }\r\n\r\n    removeController(controller) {\r\n        this.#controllers?.delete(controller);\r\n    }\r\n\r\n    createRenderRoot() {\r\n        const me = this;\r\n        const renderRoot = me.shadowRoot ?? me.attachShadow(me.constructor.shadowRootOptions);\r\n        CSS.adoptStyles(renderRoot, me.constructor.elementStyles);\r\n        return renderRoot;\r\n    }\r\n\r\n    enableUpdating(requestedUpdate) { }\r\n\r\n    firstUpdated(changedProperties) { }\r\n\r\n    updated(changedProperties) { }\r\n\r\n    getUpdateComplete() { return this.#updatePromise; }\r\n\r\n    scheduleUpdate() { return this.performUpdate(); }\r\n\r\n    shouldUpdate(changedProperties) { return true; }\r\n\r\n    willUpdate(changedProperties) { }\r\n\r\n    update(changedProperties) {\r\n        const me = this;\r\n        // The forEach() expression will only run when when #reflectingProperties is\r\n        // defined, and it returns undefined, setting #reflectingProperties to undefined\r\n        me.#reflectingProperties &&= me.#reflectingProperties.forEach((p) => me.#propertyToAttribute(p, this[p]));\r\n        me.#markUpdated();\r\n    }\r\n\r\n    get updateComplete() {\r\n        return this.getUpdateComplete();\r\n    }\r\n\r\n    requestUpdate(name, oldValue, options) {\r\n        const me = this;\r\n        if (name !== undefined) {\r\n            options ??= (me.constructor).getPropertyOptions(name);\r\n            const hasChanged = options.hasChanged ?? notEqual;\r\n            const newValue = me[name];\r\n            if (hasChanged(newValue, oldValue)) {\r\n                me.#changeProperty(name, oldValue, options);\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n        if (me.#isUpdatePending === false) {\r\n            me.#updatePromise = me.#enqueueUpdate();\r\n        }\r\n    }\r\n\r\n    performUpdate() {\r\n\r\n        const me = this;\r\n        if (!me.#isUpdatePending) return;\r\n\r\n        if (!me.#hasUpdated) {\r\n            me.#renderRoot ??= me.createRenderRoot();\r\n\r\n            // Mixin instance properties once, if they exist.\r\n            if (me.#instanceProperties) {\r\n                for (const [p, value] of me.#instanceProperties) {\r\n                    this[p] = value;\r\n                }\r\n                me.#instanceProperties = undefined;\r\n            }\r\n\r\n            const elementProperties = me.constructor.elementProperties;\r\n            if (elementProperties.size > 0) {\r\n                for (const [p, options] of elementProperties) {\r\n                    if (\r\n                        options.wrapped === true &&\r\n                        !me.#changedProperties.has(p) &&\r\n                        me[p] !== undefined\r\n                    ) {\r\n                        me.#changeProperty(p, this[p], options);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        let shouldUpdate = false;\r\n        const changedProperties = me.#changedProperties;\r\n        try {\r\n            shouldUpdate = me.shouldUpdate(changedProperties);\r\n            if (shouldUpdate) {\r\n                me.willUpdate(changedProperties);\r\n                me.#controllers?.forEach((c) => c.hostUpdate?.());\r\n                me.update(changedProperties);\r\n            } else {\r\n                me.#markUpdated();\r\n            }\r\n        } catch (e) {\r\n            shouldUpdate = false;\r\n            me.#markUpdated();\r\n            throw e;\r\n        }\r\n\r\n        if (shouldUpdate) {\r\n            me.#didUpdate(changedProperties);\r\n        }\r\n    }\r\n\r\n    // ******************************\r\n    // PRIVATE FUNCTIONS \r\n    // ******************************\r\n\r\n    #didUpdate(changedProperties) {\r\n        const me = this;\r\n        me.#controllers?.forEach((c) => c.hostUpdated?.());\r\n        if (!me.#hasUpdated) {\r\n            me.#hasUpdated = true;\r\n            me.firstUpdated(changedProperties);\r\n        }\r\n        me.updated(changedProperties);\r\n    }\r\n\r\n    #markUpdated() {\r\n        const me = this;\r\n        me.#changedProperties = new Map();\r\n        me.#isUpdatePending = false;\r\n    }\r\n\r\n    async #enqueueUpdate() {\r\n        const me = this;\r\n        me.#isUpdatePending = true;\r\n        try {\r\n            await me.#updatePromise;\r\n        } catch (e) {\r\n            Promise.reject(e);\r\n        }\r\n        const result = me.scheduleUpdate();\r\n\r\n        if (result != null) {\r\n            await result;\r\n        }\r\n        return !me.#isUpdatePending;\r\n    }\r\n\r\n    #changeProperty(name, oldValue, options) {\r\n        const me = this;\r\n        if (!me.#changedProperties.has(name)) {\r\n            me.#changedProperties.set(name, oldValue);\r\n        }\r\n\r\n        if (options.reflect === true && me.#reflectingProperty !== name) {\r\n            (me.#reflectingProperties ??= new Set()).add(name);\r\n        }\r\n    }\r\n\r\n    #attributeToProperty(name, value) {\r\n        const me = this;\r\n        const ctor = me.constructor;\r\n        const propName = (ctor[attributeToPropertyMap]).get(name);\r\n        if (propName !== undefined && me.#reflectingProperty !== propName) {\r\n            const options = ctor.getPropertyOptions(propName);\r\n            const converter =\r\n                typeof options.converter === 'function'\r\n                    ? { fromAttribute: options.converter }\r\n                    : options.converter?.fromAttribute !== undefined\r\n                        ? options.converter\r\n                        : defaultConverter;\r\n            // mark state reflecting\r\n            me.#reflectingProperty = propName;\r\n            me[propName] = converter?.fromAttribute(value, options.type);\r\n            // mark state not reflecting\r\n            me.#reflectingProperty = null;\r\n        }\r\n    }\r\n\r\n    #propertyToAttribute(name, value) {\r\n        const me = this;\r\n        const elemProperties = me.constructor.elementProperties;\r\n        const options = elemProperties?.get(name);\r\n        const attr = attributeNameForProperty(name, options);\r\n        if (attr !== undefined && options.reflect === true) {\r\n            const converter =\r\n                (options.converter)?.toAttribute !==\r\n                    undefined\r\n                    ? (options.converter)\r\n                    : defaultConverter;\r\n            const attrValue = converter?.toAttribute(value, options.type);\r\n\r\n            me.#reflectingProperty = name;\r\n            if (attrValue == null) {\r\n                me.removeAttribute(attr);\r\n            } else {\r\n                me.setAttribute(attr, attrValue);\r\n            }\r\n            // mark state not reflecting\r\n            me.#reflectingProperty = null;\r\n        }\r\n    }\r\n\r\n    #saveInstanceProperties() {\r\n        const me = this;\r\n        const instanceProperties = new Map();\r\n        const elementProperties = me.constructor.elementProperties;\r\n        for (const p of elementProperties.keys()) {\r\n            if (Object.hasOwn(me, p)) {\r\n                instanceProperties.set(p, me[p]);\r\n                delete me[p];\r\n            }\r\n        }\r\n        if (instanceProperties.size > 0) {\r\n            me.#instanceProperties = instanceProperties;\r\n        }\r\n    }\r\n\r\n    #initialize() {\r\n        const me = this;\r\n        me.#updatePromise = new Promise((res) => me.enableUpdating = res);\r\n        me.#changedProperties = new Map();\r\n        me.#saveInstanceProperties();\r\n        me.requestUpdate();\r\n        me.constructor.initializers?.forEach((i) => i(this));\r\n    }\r\n}\r\n","import { ReactiveController } from '../core/ReactiveController.mjs';\r\n\r\n/**\r\n * A simple class which stores a value, and triggers registered callbacks when\r\n * the value is changed via its setter.\r\n *\r\n * An implementor might use other observable patterns such as MobX or Redux to\r\n * get behavior like this. But this is a pretty minimal approach that will\r\n * likely work for a number of use cases.\r\n */\r\nexport class ValueNotifier extends ReactiveController {\r\n\r\n    constructor(defaultValue) {\r\n        super();\r\n        this.subscriptions = new Map();\r\n        if (defaultValue !== undefined) {\r\n            this.value = defaultValue;\r\n        }\r\n    }\r\n\r\n    get value() {\r\n        return this._value;\r\n    }\r\n\r\n    set value(v) {\r\n        this.setValue(v);\r\n    }\r\n\r\n    setValue(v, force = false) {\r\n        const update = force || !Object.is(v, this._value);\r\n        this._value = v;\r\n        if (update) {\r\n            this.updateObservers();\r\n        }\r\n    }\r\n\r\n    addCallback(callback, consumerHost, subscribe) {\r\n\r\n        if (!subscribe) {\r\n            callback(this.value);\r\n            return;\r\n        }\r\n\r\n        if (!this.subscriptions.has(callback)) {\r\n            this.subscriptions.set(callback, {\r\n                disposer: () => {\r\n                    this.subscriptions.delete(callback);\r\n                },\r\n                consumerHost,\r\n            });\r\n        }\r\n\r\n        const { disposer } = this.subscriptions.get(callback);\r\n        callback(this.value, disposer);\r\n    }\r\n\r\n    clearCallbacks() {\r\n        this.subscriptions.clear();\r\n    }\r\n\r\n    updateObservers() {\r\n        for (const [callback, { disposer }] of this.subscriptions) {\r\n            callback(this._value, disposer);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * An event fired by a context requester to signal it desires a specified context with the given key.\r\n *\r\n * A provider should inspect the `context` property of the event to determine if it has a value that can\r\n * satisfy the request, calling the `callback` with the requested value if so.\r\n *\r\n * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback\r\n * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`\r\n * method to the callback which consumers can invoke to indicate they no longer wish to receive these updates.\r\n *\r\n * If no `subscribe` value is present in the event, then the provider can assume that this is a 'one time'\r\n * request for the context and can therefore not track the consumer.\r\n */\r\nexport class ContextRequestEvent extends Event {\r\n\r\n    /**\r\n     *\r\n     * @param context the context key to request\r\n     * @param callback the callback that should be invoked when the context with the specified key is available\r\n     * @param subscribe when, true indicates we want to subscribe to future updates\r\n     */\r\n    constructor(context, callback, subscribe) {\r\n        super('context-request', { bubbles: true, composed: true });\r\n        this.context = context;\r\n        this.callback = callback;\r\n        this.subscribe = subscribe ?? false;\r\n    }\r\n}\r\n","import { ContextRequestEvent } from './events/ContextRequestEvent.mjs';\r\n\r\n/**\r\n * A ContextRoot can be used to gather unsatisfied context requests and\r\n * re-dispatch them when new providers which satisfy matching context keys are\r\n * available.\r\n *\r\n * This allows providers to be added to a DOM tree, or upgraded, after the\r\n * consumers.\r\n */\r\nexport class ContextRoot {\r\n\r\n    #request;\r\n    #provider;\r\n\r\n    constructor() {\r\n        const me = this;\r\n        me.pendingContextRequests = new Map();\r\n        me.#request = me.#onContextRequest.bind(me);\r\n        me.#provider = me.#onContextProvider.bind(me);\r\n    }\r\n\r\n    /**\r\n     * Attach the ContextRoot to a given element to intercept `context-request` and\r\n     * `context-provider` events.\r\n     *\r\n     * @param element an element to add event listeners to\r\n     */\r\n    attach(element) {\r\n        element.addEventListener('context-request', this.#request);\r\n        element.addEventListener('context-provider', this.#provider);\r\n    }\r\n\r\n    /**\r\n     * Removes the ContextRoot event listeners from a given element.\r\n     *\r\n     * @param element an element from which to remove event listeners\r\n     */\r\n    detach(element) {\r\n        element.removeEventListener('context-request', this.#request);\r\n        element.removeEventListener('context-provider', this.#provider);\r\n    }\r\n\r\n    #onContextProvider(event) {\r\n        const me = this;\r\n        const pendingRequestData = me.pendingContextRequests.get(event.context);\r\n        if (pendingRequestData === undefined) {\r\n            // No pending requests for this context at this time\r\n            return;\r\n        }\r\n\r\n        // Clear our list. Any still unsatisfied requests will re-add themselves\r\n        // when we dispatch the events below.\r\n        me.pendingContextRequests.delete(event.context);\r\n\r\n        // Loop over all pending requests and re-dispatch them from their source\r\n        const { requests } = pendingRequestData;\r\n        for (const { elementRef, callbackRef } of requests) {\r\n            const element = elementRef.deref();\r\n            const callback = callbackRef.deref();\r\n            if (element === undefined || callback === undefined) {\r\n                // The element was GC'ed. Do nothing.\r\n            } else {\r\n                // Re-dispatch if we still have the element and callback\r\n                element.dispatchEvent(new ContextRequestEvent(event.context, callback, true));\r\n            }\r\n        }\r\n    }\r\n\r\n    #onContextRequest(event) {\r\n\r\n        const me = this;\r\n\r\n        // Events that are not subscribing should not be buffered\r\n        if (event.subscribe !== true) {\r\n            return;\r\n        }\r\n\r\n        // Note, it's important to use the initial target via composedPath()\r\n        // since that's the requesting element and the event may be re-targeted\r\n        // to an outer host element.\r\n        const element = event.composedPath()[0];\r\n        const callback = event.callback;\r\n\r\n        let pendingContextRequests = me.pendingContextRequests.get(event.context);\r\n        if (pendingContextRequests === undefined) {\r\n            me.pendingContextRequests.set(event.context, (pendingContextRequests = {\r\n                callbacks: new WeakMap(),\r\n                requests: [],\r\n            }));\r\n        }\r\n\r\n        let callbacks = pendingContextRequests.callbacks.get(element);\r\n        if (callbacks === undefined) {\r\n            pendingContextRequests.callbacks.set(element, (callbacks = new WeakSet()));\r\n        }\r\n\r\n        if (callbacks.has(callback)) {\r\n            // We're already tracking this element/callback pair\r\n            return;\r\n        }\r\n\r\n        callbacks.add(callback);\r\n        pendingContextRequests.requests.push({\r\n            elementRef: new WeakRef(element),\r\n            callbackRef: new WeakRef(callback),\r\n        });\r\n    }\r\n\r\n}\r\n","import { ReactiveController } from '../../core/ReactiveController.mjs';\r\nimport { ContextRequestEvent } from '../events/ContextRequestEvent.mjs';\r\n\r\n/**\r\n * A ReactiveController which adds context consuming behavior to a custom\r\n * element by dispatching `context-request` events.\r\n *\r\n * When the host element is connected to the document it will emit a\r\n * `context-request` event with its context key. When the context request\r\n * is satisfied the controller will invoke the callback, if present, and\r\n * trigger a host update so it can respond to the new value.\r\n *\r\n * It will also call the dispose method given by the provider when the\r\n * host element is disconnected.\r\n */\r\n\r\nexport class ContextConsumer extends ReactiveController {\r\n\r\n    host = undefined;\r\n    context = undefined;\r\n    callback = undefined;\r\n    subscribe = undefined;\r\n    unsubscribe = undefined;\r\n    provided = undefined;\r\n\r\n    constructor(host, contextOrOptions, callback, subscribe) {\r\n        super();\r\n        const me = this;\r\n        me.subscribe = false;\r\n        me.provided = false;\r\n        me.value = undefined;\r\n        me.host = host;\r\n\r\n        // This is a potentially fragile duck-type. It means a context object can't\r\n        // have a property name context and be used in positional argument form.\r\n        if (contextOrOptions.context !== undefined) {\r\n            const options = contextOrOptions;\r\n            me.context = options.context;\r\n            me.callback = options.callback;\r\n            me.subscribe = options.subscribe ?? false;\r\n        } else {\r\n            me.context = contextOrOptions;\r\n            me.callback = callback;\r\n            me.subscribe = subscribe ?? false;\r\n        }\r\n\r\n        me.host.addController(this);\r\n    }\r\n\r\n    hostConnected() {\r\n        this.dispatchRequest();\r\n    }\r\n\r\n    hostDisconnected() {\r\n        const me = this;\r\n        if (me.unsubscribe) {\r\n            me.unsubscribe();\r\n            me.unsubscribe = undefined;\r\n        }\r\n    }\r\n\r\n    dispatchRequest() {\r\n        const me = this;\r\n        me.host.dispatchEvent(new ContextRequestEvent(me.context, me.#callback.bind(me), me.subscribe));\r\n    }\r\n\r\n    // This function must have stable identity to properly dedupe in ContextRoot\r\n    // if this element connects multiple times.\r\n    #callback(value, unsubscribe) {\r\n\r\n        const me = this;\r\n\r\n        // some providers will pass an unsubscribe function indicating they may provide future values\r\n        if (me.unsubscribe) {\r\n            // if the unsubscribe function changes this implies we have changed provider\r\n            if (me.unsubscribe !== unsubscribe) {\r\n                // cleanup the old provider\r\n                me.provided = false;\r\n                me.unsubscribe();\r\n            }\r\n            // if we don't support subscription, immediately unsubscribe\r\n            if (!me.subscribe) {\r\n                me.unsubscribe();\r\n            }\r\n        }\r\n        // store the value so that it can be retrieved from the controller\r\n        me.value = value;\r\n        // schedule an update in case this value is used in a template\r\n        me.host.requestUpdate();\r\n        // only invoke callback if we are either expecting updates or have not yet\r\n        // been provided a value\r\n        if (!me.provided || this.subscribe) {\r\n            me.provided = true;\r\n            if (me.callback) {\r\n                me.callback(value, unsubscribe);\r\n            }\r\n        }\r\n        me.unsubscribe = unsubscribe;\r\n    }\r\n}\r\n","\r\nexport class ContextProviderEvent extends Event {\r\n    \r\n    /**\r\n     * @param context the context which this provider can provide\r\n     */\r\n    constructor(context) {\r\n        super('context-provider', { bubbles: true, composed: true });\r\n        this.context = context;\r\n    }\r\n}","import { ContextRequestEvent } from '../events/ContextRequestEvent.mjs';\r\nimport { ContextProviderEvent } from '../events/ContextProviderEvent.mjs';\r\nimport { ValueNotifier } from '../ValueNotifier.mjs';\r\n\r\n\r\n/**\r\n * A ReactiveController which adds context provider behavior to a\r\n * custom element.\r\n *\r\n * This controller simply listens to the `context-request` event when\r\n * the host is connected to the DOM and registers the received callbacks\r\n * against its observable Context implementation.\r\n *\r\n * The controller may also be attached to any HTML element in which case it's\r\n * up to the user to call hostConnected() when attached to the DOM. This is\r\n * done automatically for any custom elements implementing\r\n * ReactiveControllerHost.\r\n */\r\nexport class ContextProvider extends ValueNotifier {\r\n\r\n    constructor(host, contextOrOptions, initialValue) {\r\n        super(contextOrOptions.context !== undefined\r\n            ? contextOrOptions.initialValue\r\n            : initialValue);\r\n\r\n        const me = this;\r\n        me.host = host;\r\n\r\n        if (contextOrOptions.context !== undefined) {\r\n            me.context = contextOrOptions.context;\r\n        } else {\r\n            me.context = contextOrOptions;\r\n        }\r\n\r\n        me.attachListeners();\r\n        me.host.addController?.(me);\r\n    }\r\n\r\n    attachListeners() {\r\n        const me = this;\r\n        me.host.addEventListener('context-request', me.#onContextRequest.bind(me));\r\n        me.host.addEventListener('context-provider', me.#onProviderRequest.bind(me));\r\n    }\r\n\r\n    hostConnected() {\r\n        // emit an event to signal a provider is available for this context\r\n        const me = this;\r\n        me.host.dispatchEvent(new ContextProviderEvent(me.context));\r\n    }\r\n\r\n    #onContextRequest(ev) {\r\n        const me = this;\r\n        // Only call the callback if the context matches.\r\n        // Also, in case an element is a consumer AND a provider\r\n        // of the same context, we want to avoid the element to self-register.\r\n        // The check on composedPath (as opposed to ev.target) is to cover cases\r\n        // where the consumer is in the shadowDom of the provider (in which case,\r\n        // event.target === this.host because of event retargeting).\r\n        const consumerHost = ev.composedPath()[0];\r\n        const isInvalid = ev.context !== me.context || consumerHost === me.host;\r\n        if (isInvalid) return;\r\n        ev.stopPropagation();\r\n        me.addCallback(ev.callback, consumerHost, ev.subscribe);\r\n    }\r\n\r\n    /**\r\n     * When we get a provider request event, that means a child of this element\r\n     * has just woken up. If it's a provider of our context, then we may need to\r\n     * re-parent our subscriptions, because is a more specific provider than us\r\n     * for its subtree.\r\n     */\r\n    #onProviderRequest(ev) {\r\n        const me = this;\r\n        // Ignore events when the context doesn't match.\r\n        // Also, in case an element is a consumer AND a provider\r\n        // of the same context it shouldn't provide to itself.\r\n        // We use composedPath (as opposed to ev.target) to cover cases\r\n        // where the consumer is in the shadowDom of the provider (in which case,\r\n        // event.target === this.host because of event retargeting).\r\n        const childProviderHost = ev.composedPath()[0];\r\n        const isInvalid = ev.context !== me.context || childProviderHost === me.host;\r\n        if (isInvalid) return;\r\n\r\n        // Re-parent all of our subscriptions in case this new child provider\r\n        // should take them over.\r\n        const seen = new Set();\r\n        for (const [callback, { consumerHost }] of me.subscriptions) {\r\n            // Prevent infinite loops in the case where a one host element\r\n            // is providing the same context multiple times.\r\n            //\r\n            // While normally it's a no-op to attempt to re-parent a subscription\r\n            // that already has its proper parent, in the case where there's more\r\n            // than one ValueProvider for the same context on the same hostElement,\r\n            // they will each call the consumer, and since they will each have their\r\n            // own dispose function, a well behaved consumer will notice the change\r\n            // in dispose function and call their old one.\r\n            //\r\n            // This will cause the subscriptions to thrash, but worse, without this\r\n            // set check here, we can end up in an infinite loop, as we add and remove\r\n            // the same subscriptions onto the end of the map over and over.\r\n            if (seen.has(callback)) continue;\r\n            seen.add(callback);\r\n            consumerHost.dispatchEvent(new ContextRequestEvent(me.context, callback, true));\r\n        }\r\n        ev.stopPropagation();\r\n    }\r\n}","const objectValueOf = Object.prototype.valueOf;\r\nconst objectToString = Object.prototype.toString;\r\nconst { keys: objectKeys } = Object;\r\nconst { isArray } = Array;\r\n\r\n// check if provided objects are valid for matching\r\nconst isMatchable = (a, b) => a !== null && b !== null && typeof a === 'object' && typeof b === 'object';\r\n\r\n// Object must have the same prototype / constructor\r\nconst isSameConstructor = (a, b) => a.constructor !== b.constructor;\r\n\r\nconst isSameType = (a, b, type) => a instanceof type && b instanceof type;\r\n\r\nconst isMap = (a, b) => isSameType(a, b, Map);\r\n\r\nconst isSet = (a, b) => isSameType(a, b, Set);\r\n\r\nconst isSizeEqual = (a, b) => a.size === b.size;\r\n\r\n// Arrays must have the same length and recursively equal items\r\nconst matchArray = (a, b) => (a.length !== b.length)  ? false : a.every((v, i) => deepEquals(v, b[i]));\r\n\r\nconst matchValue = (a, b) => a.valueOf() === b.valueOf();\r\n\r\nconst matchString = (a, b) => a.toString() === b.toString();\r\n\r\nconst matchRegExp = (a, b) => a.source === b.source && a.flags === b.flags;\r\n\r\nconst matchMap = (a, b) => {\r\n    if (!isSizeEqual(a, b)) return false;\r\n    for (const [k, v] of a.entries()) {\r\n        if (deepEquals(v, b.get(k)) === false ||\r\n            (v === undefined && b.has(k) === false)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;    \r\n}\r\n\r\nconst matchSet = (a, b) => {\r\n    if (!isSizeEqual(a, b)) return false;\r\n    for (const k of a.keys()) {\r\n        if (b.has(k) === false) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// We have two objects, check every key\r\nconst matchObjects = (a, b) => {\r\n        const keys = objectKeys(a);\r\n        if (keys.length !== objectKeys(b).length) {\r\n            return false;\r\n        }\r\n        \r\n        for (const key of keys) {\r\n            if (!Object.hasOwn(b, key) || !deepEquals(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n}\r\n\r\n/**\r\n * Recursively checks two objects for equality.\r\n *\r\n * This function handles the following cases:\r\n *  - Primitives: primitives compared with Object.is()\r\n *  - Objects: to be equal, two objects must:\r\n *    - have the same constructor\r\n *    - have same set of own property names\r\n *    - have each own property be deeply equal\r\n *  - Arrays, Maps, Sets, and RegExps\r\n *  - Objects with custom valueOf() (ex: Date)\r\n *  - Objects with custom toString() (ex: URL)\r\n *\r\n * Important: Objects must be free of cycles, otherwise this function will\r\n * run infinitely!\r\n */\r\nexport const deepEquals = (a, b) => {\r\n\r\n    if (Object.is(a, b)) return true;\r\n\r\n    if (!isMatchable(a, b)) return false;\r\n\r\n    if (!isSameConstructor(a, b)) return false;\r\n\r\n    if (isArray(a)) return matchArray(a, b);\r\n\r\n    // Defer to custom valueOf implementations. This handles Dates which return\r\n    // ms since epoch: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/valueOf\r\n    if (a.valueOf !== objectValueOf) return matchValue(a, b);\r\n\r\n    // Defer to custom toString implementations. This should handle\r\n    // TrustedTypes, URLs, and such. This might be a bit risky, but\r\n    // fast-deep-equals does it.\r\n    if (a.toString !== objectToString) return matchString(a, b);\r\n\r\n    if (isMap(a, b)) return matchMap(a, b);\r\n\r\n    if (isSet(a, b, Set)) return matchSet(a, b);\r\n\r\n    if (a instanceof RegExp) return matchRegExp(a, b);\r\n\r\n    if (!matchObjects(a, b)) return false;\r\n    \r\n    // All keys in the two objects have been compared!\r\n    return true;\r\n}\r\n\r\nexport const deepArrayEquals = (oldArgs, newArgs) => oldArgs === newArgs ||\r\n    (oldArgs.length === newArgs.length &&\r\n        oldArgs.every((v, i) => deepEquals(v, newArgs[i])));\r\n","\r\nexport const shallowArrayEquals = (oldArgs, newArgs) => oldArgs === newArgs ||\r\n    (oldArgs.length === newArgs.length && oldArgs.every((v, i) => Object.is(v, newArgs[i])));\r\n\r\n","\r\nimport { ReactiveController } from '../core/ReactiveController.mjs';\r\nimport { shallowArrayEquals } from './shallow-equals.mjs';\r\n\r\n/**\r\n * States for task status\r\n */\r\nexport const TaskStatus = {\r\n    INITIAL: 0,\r\n    PENDING: 1,\r\n    COMPLETE: 2,\r\n    ERROR: 3,\r\n}\r\n\r\n/**\r\n * A special value that can be returned from task functions to reset the task\r\n * status to INITIAL.\r\n */\r\nexport const initialState = Symbol();\r\n\r\n// TODO(sorvell / justinfagnani): Some issues:\r\n// 1. With the task triggered in `update`, there is no ReactiveElement\r\n// change-in-update warning in the common case that the update itself does not change\r\n// the deps; however, Task's `requestUpdate` call to render pending state  will not\r\n// trigger another update since the element is updating. This `requestUpdate`\r\n// could be triggered in updated, but that results a change-in-update warning.\r\n// 2. There is no good signal for when the task has resolved and rendered other\r\n// than requestAnimationFrame. The user would need to store a promise for the\r\n// task and then wait for that and the element to update. (Update just justinfagnani:\r\n// Why isn't waiting taskComplete and updateComplete sufficient? This comment is\r\n// from before taskComplete existed!)\r\n\r\n/**\r\n * A controller that performs an asynchronous task (like a fetch) when its\r\n * host element updates.\r\n *\r\n * Task requests an update on the host element when the task starts and\r\n * completes so that the host can render the task status, value, and error as\r\n * the task runs.\r\n *\r\n * The task function must be supplied and can take a list of arguments. The\r\n * arguments are given to the Task as a function that returns a list of values,\r\n * which is run and checked for changes on every host update.\r\n *\r\n * The `value` property reports the completed value, and the `error` property\r\n * an error state if one occurs. The `status` property can be checked for\r\n * status and is of type `TaskStatus` which has states for initial, pending,\r\n * complete, and error.\r\n *\r\n * The `render` method accepts an object with optional methods corresponding\r\n * to the task statuses to easily render different templates for each task\r\n * status.\r\n *\r\n * The task is run automatically when its arguments change; however, this can\r\n * be customized by setting `autoRun` to false and calling `run` explicitly\r\n * to run the task.\r\n *\r\n * For a task to see state changes in the current update pass of the host\r\n * element, those changes must be made in `willUpdate()`. State changes in\r\n * `update()` or `updated()` will not be visible to the task until the next\r\n * update pass.\r\n *\r\n * @example\r\n *\r\n * ```js\r\n * class MyElement extends ReactiveComponent {\r\n * \r\n *   url = 'example.com/api';\r\n *   id = 0;\r\n *\r\n *   task = new Task(\r\n *     this,\r\n *     {\r\n *       task: async ([url, id]) => {\r\n *         const response = await fetch(`${this.url}?id=${this.id}`);\r\n *         if (!response.ok) {\r\n *           throw new Error(response.statusText);\r\n *         }\r\n *         return response.json();\r\n *       },\r\n *       args: () => [this.id, this.url],\r\n *     }\r\n *   );\r\n *\r\n *   render() {\r\n *     return this.task.render({\r\n *       pending: () => html`<p>Loading...</p>`,\r\n *       complete: (value) => html`<p>Result: ${value}</p>`\r\n *     });\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport class Task extends ReactiveController {\r\n\r\n    #callId;\r\n    #host;\r\n    #task;\r\n    #argsFn;\r\n    #argsEqual;\r\n    #onComplete;\r\n    #onError;\r\n    #error;\r\n    #value;\r\n    #previousArgs;\r\n    #abortController;\r\n    #taskComplete;\r\n    #resolveTaskComplete;\r\n    #rejectTaskComplete;\r\n\r\n    /**\r\n     * A Promise that resolve when the current task run is complete.\r\n     *\r\n     * If a new task run is started while a previous run is pending, the Promise\r\n     * is kept and only resolved when the new run is completed.\r\n     */\r\n    get taskComplete() {\r\n\r\n        const me = this;\r\n\r\n        // If a task run exists, return the cached promise. This is true in the case\r\n        // where the user has called taskComplete in pending or completed state\r\n        // before and has not started a new task run since.\r\n        if (me.#taskComplete) {\r\n            return me.#taskComplete;\r\n        }\r\n\r\n        // Generate an in-progress promise if the the status is pending and has been\r\n        // cleared by .run().\r\n        if (me.status === TaskStatus.PENDING) {\r\n            me.#taskComplete = new Promise((res, rej) => {\r\n                me.#resolveTaskComplete = res;\r\n                me.#rejectTaskComplete = rej;\r\n            });\r\n            // If the status is error, return a rejected promise.\r\n        } else if (me.status === TaskStatus.ERROR) {\r\n            me.#taskComplete = Promise.reject(me.#error);\r\n            // Otherwise we are at a task run's completion or this is the first\r\n            // request and we are not in the middle of a task (i.e. INITIAL).\r\n        } else {\r\n            me.#taskComplete = Promise.resolve(me.#value);\r\n        }\r\n\r\n        return me.#taskComplete;\r\n    }\r\n\r\n    constructor(host, task, args) {\r\n        super();\r\n        const me = this;\r\n        me.#callId = 0;\r\n        me.status = TaskStatus.INITIAL;\r\n        (me.#host = host).addController(me);\r\n        const taskConfig = typeof task === 'object' ? task : { task, args };\r\n        me.#task = taskConfig.task;\r\n        me.#argsFn = taskConfig.args;\r\n        me.#argsEqual = taskConfig.argsEqual ?? shallowArrayEquals;\r\n        me.#onComplete = taskConfig.onComplete;\r\n        me.#onError = taskConfig.onError;\r\n        me.autoRun = taskConfig.autoRun ?? true;\r\n\r\n        // Providing initialValue puts the task in COMPLETE state and stores the\r\n        // args immediately so it only runs when they change again.\r\n        if ('initialValue' in taskConfig) {\r\n            me.#value = taskConfig.initialValue;\r\n            me.status = TaskStatus.COMPLETE;\r\n            me.#previousArgs = me.#getArgs?.();\r\n        }\r\n    }\r\n\r\n    hostUpdate() {\r\n        if (this.autoRun === true) {\r\n            this.#performTask();\r\n        }\r\n    }\r\n\r\n    hostUpdated() {\r\n        if (this.autoRun === 'afterUpdate') {\r\n            this.#performTask();\r\n        }\r\n    }\r\n\r\n    #getArgs() {\r\n\r\n        const me = this;\r\n        if (me.#argsFn === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        const args = me.#argsFn();\r\n        if (!Array.isArray(args)) {\r\n            throw new Error('The args function must return an array');\r\n        }\r\n\r\n        return args;\r\n    }\r\n\r\n    /**\r\n     * Determines if the task should run when it's triggered because of a\r\n     * host update, and runs the task if it should.\r\n     *\r\n     * A task should run when its arguments change from the previous run, based on\r\n     * the args equality function.\r\n     *\r\n     * This method is side-effectful: it stores the new args as the previous args.\r\n     */\r\n    async #performTask() {\r\n\r\n        const me = this;\r\n        const args = me.#getArgs();\r\n        const prev = me.#previousArgs;\r\n        me.#previousArgs = args;\r\n\r\n        if (args !== prev &&\r\n            args !== undefined &&\r\n            (prev === undefined || !me.#argsEqual(prev, args))) {\r\n            await me.run(args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs a task manually.\r\n     *\r\n     * This can be useful for running tasks in response to events as opposed to\r\n     * automatically running when host element state changes.\r\n     *\r\n     * @param args an optional set of arguments to use for this task run. If args\r\n     *     is not given, the args function is called to get the arguments for\r\n     *     this run.\r\n     */\r\n    async run(args) {\r\n\r\n        const me = this;\r\n        args ??= me.#getArgs();\r\n\r\n        // Remember the args for potential future automatic runs.\r\n        // TODO (justinfagnani): add test\r\n        me.#previousArgs = args;\r\n        if (me.status === TaskStatus.PENDING) {\r\n            me.#abortController?.abort();\r\n        } else {\r\n            // Clear the last complete task run in INITIAL because it may be a resolved\r\n            // promise. Also clear if COMPLETE or ERROR because the value returned by\r\n            // awaiting taskComplete may have changed since last run.\r\n            me.#taskComplete = undefined;\r\n            me.#resolveTaskComplete = undefined;\r\n            me.#rejectTaskComplete = undefined;\r\n        }\r\n\r\n        me.status = TaskStatus.PENDING;\r\n        let result;\r\n        let error;\r\n\r\n        // Request an update to report pending state.\r\n        if (me.autoRun === 'afterUpdate') {\r\n            // Avoids a change-in-update warning\r\n            queueMicrotask(() => me.#host.requestUpdate());\r\n        } else {\r\n            me.#host.requestUpdate();\r\n        }\r\n\r\n        const key = ++this.#callId;\r\n        me.#abortController = new AbortController();\r\n        let errored = false;\r\n\r\n        try {\r\n            result = await me.#task(args, { signal: this.#abortController.signal });\r\n        } catch (e) {\r\n            errored = true;\r\n            error = e;\r\n        }\r\n\r\n        // If this is the most recent task call, process this value.\r\n        if (me.#callId === key) {\r\n            if (result === initialState) {\r\n                me.status = TaskStatus.INITIAL;\r\n            } else {\r\n                if (errored === false) {\r\n                    try {\r\n                        me.#onComplete?.(result);\r\n                    } catch {\r\n                        // Ignore user errors from onComplete.\r\n                    }\r\n                    me.status = TaskStatus.COMPLETE;\r\n                    me.#resolveTaskComplete?.(result);\r\n                } else {\r\n                    try {\r\n                        me.#onError?.(error);\r\n                    } catch {\r\n                        // Ignore user errors from onError.\r\n                    }\r\n                    me.status = TaskStatus.ERROR;\r\n                    me.#rejectTaskComplete?.(error);\r\n                }\r\n                me.#value = result;\r\n                me.#error = error;\r\n            }\r\n\r\n            // Request an update with the final value.\r\n            me.#host.requestUpdate();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Aborts the currently pending task run by aborting the AbortSignal\r\n     * passed to the task function.\r\n     *\r\n     * Aborting a task does nothing if the task is not running: ie, in the\r\n     * complete, error, or initial states.\r\n     *\r\n     * Aborting a task does not automatically cancel the task function. The task\r\n     * function must be written to accept the AbortSignal and either forward it\r\n     * to other APIs like `fetch()`, or handle cancellation manually by using\r\n     * [`signal.throwIfAborted()`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted}\r\n     * or the\r\n     * [`abort`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/abort_event}\r\n     * event.\r\n     *\r\n     * @param reason The reason for aborting. Passed to\r\n     *     `AbortController.abort()`.\r\n     */\r\n    abort(reason) {\r\n        if (this.status === TaskStatus.PENDING) {\r\n            this.#abortController?.abort(reason);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The result of the previous task run, if it resolved.\r\n     *\r\n     * Is `undefined` if the task has not run yet, or if the previous run errored.\r\n     */\r\n    get value() {\r\n        return this.#value;\r\n    }\r\n\r\n    /**\r\n     * The error from the previous task run, if it rejected.\r\n     *\r\n     * Is `undefined` if the task has not run yet, or if the previous run\r\n     * completed successfully.\r\n     */\r\n    get error() {\r\n        return this.#error;\r\n    }\r\n\r\n    render(renderer) {\r\n        switch (this.status) {\r\n            case TaskStatus.INITIAL:\r\n                return renderer.initial?.();\r\n            case TaskStatus.PENDING:\r\n                return renderer.pending?.();\r\n            case TaskStatus.COMPLETE:\r\n                return renderer.complete?.(this.value);\r\n            case TaskStatus.ERROR:\r\n                return renderer.error?.(this.error);\r\n            default:\r\n                throw new Error(`Unexpected status: ${this.status}`);\r\n        }\r\n    }\r\n}\r\n\r\n","import { ReactiveElement } from './core/ReactiveElement.mjs';\r\nimport { DynamicHTML, noChange } from './html/index.mjs';\r\n\r\nexport class ReactiveComponent extends ReactiveElement {\r\n\r\n  #renderOptions = { host: this };\r\n\r\n  #childPart = undefined;\r\n\r\n  get renderOptions() { return this.#renderOptions; }\r\n\r\n  /**\r\n   * @category rendering\r\n   */\r\n  createRenderRoot() {\r\n    const renderRoot = super.createRenderRoot();\r\n    // When adoptedStyleSheets are shimmed, they are inserted into the\r\n    // shadowRoot by createRenderRoot. Adjust the renderBefore node so that\r\n    // any styles in Lit content render before adoptedStyleSheets. This is\r\n    // important so that adoptedStyleSheets have precedence over styles in\r\n    // the shadowRoot.\r\n    this.renderOptions.renderBefore ??= renderRoot?.firstChild;\r\n    return renderRoot;\r\n  }\r\n\r\n  /**\r\n   * Updates the element. This method reflects property values to attributes\r\n   * and calls `render` to render DOM via lit-html. Setting properties inside\r\n   * this method will *not* trigger another update.\r\n   * @param changedProperties Map of changed properties with old values\r\n   * @category updates\r\n   */\r\n  update(changedProperties) {\r\n    // Setting properties in `render` should not trigger an update. Since\r\n    // updates are allowed after super.update, it's important to call `render`\r\n    // before that.\r\n    const me = this;\r\n    const value = me.render();\r\n    if (!me.hasUpdated) me.renderOptions.isConnected = me.isConnected;\r\n    super.update(changedProperties);\r\n    me.#childPart = DynamicHTML.render(value, me.renderRoot, me.renderOptions);\r\n  }\r\n\r\n  /**\r\n   * Invoked when the component is added to the document's DOM.\r\n   *\r\n   * In `connectedCallback()` you should setup tasks that should only occur when\r\n   * the element is connected to the document. The most common of these is\r\n   * adding event listeners to nodes external to the element, like a keydown\r\n   * event handler added to the window.\r\n   *\r\n   * ```ts\r\n   * connectedCallback() {\r\n   *   super.connectedCallback();\r\n   *   addEventListener('keydown', this._handleKeydown);\r\n   * }\r\n   * ```\r\n   *\r\n   * Typically, anything done in `connectedCallback()` should be undone when the\r\n   * element is disconnected, in `disconnectedCallback()`.\r\n   *\r\n   * @category lifecycle\r\n   */\r\n  connectedCallback() {\r\n    super.connectedCallback();\r\n    this.#childPart?.setConnected(true);\r\n  }\r\n\r\n  /**\r\n   * Invoked when the component is removed from the document's DOM.\r\n   *\r\n   * This callback is the main signal to the element that it may no longer be\r\n   * used. `disconnectedCallback()` should ensure that nothing is holding a\r\n   * reference to the element (such as event listeners added to nodes external\r\n   * to the element), so that it is free to be garbage collected.\r\n   *\r\n   * ```ts\r\n   * disconnectedCallback() {\r\n   *   super.disconnectedCallback();\r\n   *   window.removeEventListener('keydown', this._handleKeydown);\r\n   * }\r\n   * ```\r\n   *\r\n   * An element may be re-connected after being disconnected.\r\n   *\r\n   * @category lifecycle\r\n   */\r\n  disconnectedCallback() {\r\n    super.disconnectedCallback();\r\n    this.#childPart?.setConnected(false);\r\n  }\r\n\r\n  /**\r\n   * Invoked on each update to perform rendering tasks. This method may return\r\n   * any value renderable by lit-html's `ChildPart` - typically a\r\n   * `TemplateResult`. Setting properties inside this method will *not* trigger\r\n   * the element to update.\r\n   * @category rendering\r\n   */\r\n  render() {\r\n    return noChange;\r\n  }\r\n}\r\n\r\n// for compatibility with Lit 3.0\r\nexport const LitElement = ReactiveComponent;"],"names":["partSymbol","Symbol","typeSymbol","directiveSymbol","notifySymbol","noChange","for","nothing","PartType","ATTRIBUTE","CHILD","PROPERTY","BOOLEAN","EVENT","ELEMENT","COMMENT","Object","seal","ResultType","HTML","SVG","boundAttributeSuffix","marker","String","Math","random","slice","markerMatch","nodeMarker","createMarker","document","createComment","isPrimitive","value","isArray","Array","isIterable","iterator","walker","createTreeWalker","ENABLE_EXTRA_SECURITY_HOOKS","trustedTypes","globalThis","policy","createPolicy","createHTML","s","undefined","identityFunction","noopSanitizer","_node","_name","_type","sanitizerFactoryInternal","setSanitizer","newSanitizer","Error","isNoOp","sanityze","createSanitizer","node","name","type","trustFromTemplateString","tsa","stringFromTSA","hasOwn","BasePart","resolveDirective","part","parent","attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","constructor","_$initialize","this","_$resolve","values","AttributePart","tagName","element","_$isConnected","_$parent","strings","options","super","_$committedValue","_$disconnectableChildren","length","fill","_sanitizer","_$setValue","directiveParent","valueIndex","noCommit","change","i","v","_commitValue","removeAttribute","setAttribute","BooleanAttributePart","arguments","toggleAttribute","EventPart","newListener","oldListener","shouldRemoveListener","capture","once","passive","shouldAddListener","removeEventListener","addEventListener","handleEvent","event","call","host","PropertyPart","textEndRegex","SPACE_CHAR","commentEndRegex","comment2EndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","tagEndRegex","RegExp","rawTextElement","getTemplateHtml","l","attrNames","rawTextEndRegex","html","regex","attrName","match","attrNameEndIndex","lastIndex","exec","test","end","startsWith","push","htmlResult","Template","createElement","_options","el","innerHTML","nodeIndex","attrNameIndex","partCount","me","parts","handleSVG","handleTemplate","svgElement","content","firstChild","replaceWith","childNodes","currentNode","nextNode","nodeType","handleElement","handleComment","hasAttributes","handleAttributes","handleText","getAttributeNames","endsWith","realName","statics","getAttribute","split","m","index","ctor","textContent","emptyScript","append","data","indexOf","ChildPart","static","WeakMap","__isConnected","startNode","endNode","_$startNode","_$endNode","isConnected","_textSanitizer","parentNode","_$clear","_commitText","_commitTemplateResult","_commitNode","_commitIterable","_insert","insertBefore","parentNodeName","nodeName","nextSibling","textNode","createTextNode","result","template","_$getTemplate","h","_$template","_update","instance","TemplateInstance","fragment","_clone","cache","templateCache","get","set","itemParts","itemPart","partIndex","item","start","from","_$notifyConnectionChanged","n","remove","setConnected","ElementPart","_$parts","creationScope","importNode","templatePart","DynamicHTML","tag","render","container","partOwnerNode","renderBefore","svg","StaticHTML","Map","r","brand","propertySymbol","reduce","acc","idx","textFromStatic","coreTag","staticStrings","dynamicValues","staticValue","dynamicValue","hasStatics","unwrapStaticValue","key","join","stringsCache","raw","withStatic","unsafeStatic","literal","staticHtml","staticSvg","isTemplateResult","isCompiledTemplateResult","isDirectiveResult","getDirectiveClass","isSingleExpression","insertPart","containerPart","refPart","refNode","oldParent","parentChanged","newConnectionState","_$reparentDisconnectables","setChildPartValue","RESET_VALUE","setCommittedValue","getCommittedValue","removePart","clearPart","directive","c","Directive","_partInfo","__part","__attributeIndex","props","update","_part","notifyChildrenConnectedChanged","children","obj","removeDisconnectableFromParent","delete","size","addDisconnectableToParent","Set","has","add","installDisconnectAPI","reparentDisconnectables","newParent","notifyChildPartConnectedChanged","isClearingValue","fromPartIndex","AsyncDirective","isClearingDirective","reconnected","disconnected","setValue","newValues","forAwaitOf","async","iterable","callback","PseudoWeakRef","ref","_ref","disconnect","reconnect","deref","Pauser","_promise","_resolve","pause","Promise","resolve","resume","AsyncReplaceDirective","weakThis","pauser","mapper","__value","commitValue","asyncReplace","asyncAppend","AsyncAppendDirective","partInfo","params","__childPart","newPart","getStringsFromTemplateResult","CacheDirective","valueKey","vKey","store","restore","childPart","pop","cachedContainerPart","createDocumentFragment","cachedPart","choose","cases","defaultCase","fn","classMap","ClassMapDirective","classInfo","keys","filter","_previousClasses","_staticClasses","classList","initialValue","guard","GuardDirective","_previousValue","_value","f","every","ifDefined","items","joiner","isFunction","keyed","Keyed","k","live","LiveDirective","hasAttribute","map","range","startOrEnd","step","createRef","Ref","lastElementForContextAndCallback","RefDirective","refChanged","_updateRefValue","_lastElementForRef","_element","_context","context","lastElementForCallback","generateMap","list","repeat","RepeatDirective","_getValuesAndKeys","keyFnOrTemplate","keyFn","oldParts","newKeys","_itemKeys","oldKeys","newParts","newKeyToIndexMap","oldKeyToIndexMap","oldHead","oldTail","newHead","newTail","oldIndex","oldPart","important","importantFlag","styleMap","StyleMapDirective","styleInfo","style","prop","includes","replace","toLowerCase","_previousStyleProperties","removeProperty","isImportant","setProperty","templateContent","TemplateContentDirective","_previousTemplate","UnsafeHTMLDirective","directiveName","_templateResult","resultType","unsafeHTML","UnsafeSVGDirective","unsafeSVG","isPromise","x","then","_infinity","UntilDirective","__lastRenderedIndex","__values","__weakThis","__pauser","args","find","previousValues","previousLength","_this","until","when","condition","trueCase","falseCase","emptyStringForBooleanAttribute","AttributeConverter","toAttribute","Boolean","JSON","stringify","fromAttribute","fromValue","Number","parse","e","ReactiveController","hostConnected","hostDisconnected","hostUpdate","hostUpdated","ReactiveControllerHost","addController","controller","removeController","requestUpdate","updateComplete","supportsAdoptingStyleSheets","ShadowRoot","Document","prototype","CSSStyleSheet","constructionToken","symbolResult","CSSResult","styleSheet","cssText","safeToken","cacheable","read","replaceSync","write","toString","cssTagCache","CSS","textFromCSSResult","sheet","rule","cssRules","unsafeCSS","createStyle","nonce","css","adoptStyles","renderRoot","styles","adoptedStyleSheets","forEach","appendChild","getCompatibleStyle","cssResultFromStyleSheet","defaultConverter","notEqual","val","old","is","defaultPropertyDeclaration","attribute","reflect","converter","hasChanged","attributeToPropertyMap","prepare","prepareFn","superCtor","getPrototypeOf","finalize","elementProperties","attributeNameForProperty","metadata","ReactivePropertyMetadata","ReactiveElement","HTMLElement","mode","reflectingProperties","instanceProperties","controllers","updatePromise","changedProperties","reflectingProperty","hasUpdated","isUpdatePending","observedAttributes","defineProperty","__proto__","addInitializer","initializer","initializers","finalized","properties","propKeys","getOwnPropertyNames","getOwnPropertySymbols","p","createProperty","attr","elementStyles","finalizeStyles","flat","Infinity","reverse","unshift","state","noAccessor","descriptor","getPropertyDescriptor","getOwnPropertyDescriptor","oldValue","configurable","enumerable","getPropertyOptions","initialize","connectedCallback","createRenderRoot","enableUpdating","disconnectedCallback","attributeChangedCallback","newValue","attributeToProperty","shadowRoot","attachShadow","shadowRootOptions","requestedUpdate","firstUpdated","updated","getUpdateComplete","scheduleUpdate","performUpdate","shouldUpdate","willUpdate","propertyToAttribute","markUpdated","changeProperty","enqueueUpdate","wrapped","didUpdate","reject","propName","elemProperties","attrValue","saveInstanceProperties","res","ValueNotifier","defaultValue","subscriptions","force","updateObservers","addCallback","consumerHost","subscribe","disposer","clearCallbacks","clear","ContextRequestEvent","Event","bubbles","composed","ContextRoot","request","provider","pendingContextRequests","onContextRequest","bind","onContextProvider","attach","detach","pendingRequestData","requests","elementRef","callbackRef","dispatchEvent","composedPath","callbacks","WeakSet","WeakRef","ContextConsumer","unsubscribe","provided","contextOrOptions","dispatchRequest","ContextProviderEvent","ContextProvider","attachListeners","onProviderRequest","ev","stopPropagation","childProviderHost","seen","objectValueOf","valueOf","objectToString","objectKeys","isSameType","a","b","isSizeEqual","deepEquals","isMatchable","isSameConstructor","matchArray","matchValue","matchString","isMap","entries","matchMap","isSet","matchSet","source","flags","matchRegExp","matchObjects","deepArrayEquals","oldArgs","newArgs","shallowArrayEquals","TaskStatus","INITIAL","PENDING","COMPLETE","ERROR","initialState","Task","callId","task","argsFn","argsEqual","onComplete","onError","error","previousArgs","abortController","taskComplete","resolveTaskComplete","rejectTaskComplete","status","rej","taskConfig","autoRun","getArgs","performTask","prev","run","abort","queueMicrotask","AbortController","errored","signal","reason","renderer","initial","pending","complete","ReactiveComponent","renderOptions","LitElement"],"mappings":"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"}