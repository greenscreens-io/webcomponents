{"version":3,"file":"io.greenscreens.worker.min.js","sources":["../../modules/worker/Cache.mjs","../../modules/worker/Filter.mjs","../../modules/worker/Worker.mjs"],"sourcesContent":["/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\n/**\r\n * CacheEngine class provides a simple interface to manage caching of resources using the Cache API.\r\n */\r\nexport class CacheEngine {\r\n\r\n  #name;\r\n\r\n  /**\r\n   * Creates an instance of CacheEngine with a specified cache name.\r\n   * @param {*} name \r\n   */\r\n  constructor(name) {\r\n    if (!('caches' in self)) {\r\n      throw new Error('Cache API is not supported in this browser.');     \r\n    }\r\n    this.#name = name || 'DefaultCache';\r\n  }\r\n\r\n  /**\r\n   * Returns the name of the cache.\r\n   */\r\n  get name() {\r\n    return this.#name;\r\n  }\r\n  \r\n  /**\r\n   * Initialize the cache engine.\r\n   * This should be called first before using the cahe engine.\r\n   * @returns \r\n   */\r\n  async init() {  \r\n    return caches.open(this.#name);\r\n  }\r\n\r\n  /**\r\n   * Add resources to cache.\r\n   * @param {*} resources \r\n   * @returns \r\n   */\r\n  async addResourcesToCache(resources) {\r\n    const cache = await this.init(); \r\n    return cache.addAll(resources);\r\n  }\r\n\r\n  /**\r\n   * Put the response in cache for the given request.\r\n   * @param {*} request \r\n   * @param {*} response \r\n   * @returns \r\n   */\r\n  async putInCache(request, response) {\r\n    const cache = await this.init();\r\n    return cache.put(request, response);\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache for the given request.\r\n   * @param {*} request \r\n   * @returns \r\n   */\r\n  async getFromCache(request) {\r\n    const cache = await this.init();\r\n    return cache.match(request);\r\n  }\r\n\r\n  /**\r\n   * Fetch resource from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @param {*} event\r\n   * @returns \r\n   */\r\n  async fetchAndCache(request, event) { \r\n    const me = this;\r\n    const fetchedResponse = await fetch(request);\r\n    if (fetchedResponse.ok) {\r\n      if (event) {\r\n        event.waitUntil(me.putInCache(request, fetchedResponse.clone()));\r\n      } else {\r\n        await me.putInCache(request, fetchedResponse.clone());\r\n      }\r\n    }\r\n    return fetchedResponse;\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache first, if not found, \r\n   * fetch it from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @param {*} event \r\n   * @returns Promise<Response>\r\n   */\r\n  async cacheFirst(request, event) {\r\n    const me = this;\r\n\r\n    // Try to get the request from cache first\r\n    const responseFromCache = await me.getFromCache(request);\r\n    if (responseFromCache) return responseFromCache;\r\n    \r\n    // Next try to use (and cache) the preloaded response, if it's there\r\n    const preloadResponse = await event?.preloadResponse;\r\n    if (preloadResponse) {\r\n      event.waitUntil(me.putInCache(request, preloadResponse.clone()));\r\n      return preloadResponse;\r\n    }    \r\n\r\n    // Finally, fetch from network and cache the response\r\n    return me.fetchAndCache(request, event);\r\n  }\r\n\r\n  async clearCache() {\r\n    const cache = await this.init();\r\n    return cache.keys().then(keys => {\r\n      return Promise.all(keys.map(key => cache.delete(key)));\r\n    }); \r\n  }\r\n\r\n}","/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\n/**\r\n * FilterEngine class provides a simple interface to manage filters for fetch requests.\r\n * It allows registering and unregistering functions that can be used to match requests against specific criteria.\r\n */\r\nexport class FilterEngine {\r\n\r\n  #filters = new Map();\r\n\r\n  constructor(filters) {\r\n    this.registerAll(filters);\r\n  }\r\n\r\n  registerAll(filters = []) {\r\n    const me = this;\r\n    for (const filter of filters) {\r\n      if (typeof filter.name !== 'string') {\r\n        console.warn('Invalid filter format. Expected { name: string, fn: function }');\r\n        continue;\r\n      }\r\n\r\n      if (typeof filter.rule === 'string') {\r\n        filter.rule = new RegExp(filter.rule);\r\n      }\r\n\r\n      if (filter.fn) {\r\n        me.register(filter.name, filter.fn);\r\n      } else if (filter.rule instanceof RegExp) {\r\n        me.register(filter.name, me.#regexFilter(filter));\r\n      }\r\n    }\r\n  }\r\n\r\n  #regexFilter(filter) {\r\n    const rule = filter.rule;\r\n    const parsed = filter.parsed ? true : false;\r\n    return (request) => {\r\n      rule.lastIndex = 0;\r\n      return parsed ?\r\n        rule.test(URL.parse(request.url).pathname.toLowerCase())\r\n        :\r\n        rule.test(request.url.toLowerCase());\r\n    };\r\n  }\r\n\r\n  register(name, filter) {\r\n    if (this.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} already exists.`);\r\n      return;\r\n    }\r\n    this.#filters.set(name, filter);\r\n  }\r\n\r\n  unregister(name) {\r\n    if (!this.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} does not exist.`);\r\n      return;\r\n    }\r\n    this.#filters.delete(name);\r\n  }\r\n\r\n  match(request) {\r\n    for (const [name, filter] of this.#filters.entries()) {\r\n      if (filter(request)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\nimport { FilterEngine } from \"./Filter.mjs\";\r\nimport { CacheEngine } from \"./Cache.mjs\";\r\n\r\n// https://github.com/mdn/serviceworker-cookbook\r\n\r\n/**\r\n * WorkerEngine class provides a simple interface to manage service worker lifecycle events,\r\n * caching strategies, and push notifications.\r\n */\r\nexport class WorkerEngine {\r\n\r\n  #trace = false;\r\n  #options = null;\r\n  #filter = null;\r\n  #cache = null;\r\n\r\n  #notificationOptions = {\r\n    title: \"Refresh now?\",\r\n    body: \"New version of the app is available.\",\r\n    requireInteraction: true,\r\n    actions: [\r\n      { action: 'refresh', title: 'Refresh' },\r\n      { action: 'cancel', title: 'Cancel' }\r\n    ],\r\n    data: {}\r\n  };\r\n\r\n  constructor(options) {\r\n    const me = this;\r\n    me.#options = options || {};\r\n    me.#trace = options?.trace || false;\r\n    me.#filter = new FilterEngine(options?.filters || []);\r\n    me.#cache = new CacheEngine(options?.cacheName || 'DefaultCache');\r\n    self.addEventListener('install', me.#onInstall.bind(me));\r\n    self.addEventListener('activate', me.#onActivate.bind(me));\r\n    self.addEventListener('push', me.#onPush.bind(me));\r\n    self.addEventListener('sync', me.#onSync.bind(me));\r\n    self.addEventListener('fetch', me.#onFetch.bind(me));\r\n    self.addEventListener('message', me.#onMessage.bind(me));\r\n    self.addEventListener('messageerror', me.#onMessageError.bind(me));\r\n    self.addEventListener('notificationclick', me.#onNotification.bind(me));\r\n  }\r\n\r\n  async #precacheURL() {\r\n    const me = this;\r\n    if (me.#options?.preCacheURL) {\r\n      me.trace('Precached JSON definition:', me.#options?.preCacheURL);\r\n      const response = await fetch(me.#options.preCacheURL);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to fetch precache URL: ${me.#options.preCacheURL}`);\r\n      }\r\n      const filesToCache = await response.json();\r\n      me.trace('Precached files:', filesToCache);\r\n      await me.#cache.addResourcesToCache(filesToCache);\r\n    }\r\n  }\r\n\r\n  async #precacheAssets() {\r\n    const me = this;\r\n    if (me.#options?.precachedAssets) {\r\n      me.trace('Precached assets:', me.#options?.precachedAssets);\r\n      await me.#cache.addResourcesToCache(me.#options.precachedAssets)\r\n    }\r\n  }\r\n\r\n  async #precache() {\r\n    const me = this;\r\n    await me.#precacheURL();\r\n    await me.#precacheAssets();\r\n  }\r\n\r\n  #onInstall(event) {\r\n    const me = this;\r\n    me.trace('Service Worker installing:', event);\r\n    event.waitUntil(me.#precache());\r\n  }\r\n\r\n  #onActivate(event) {\r\n    const me = this;\r\n    me.trace('Service Worker activated:', event);\r\n    if (me.#options?.preload) event.waitUntil(me.#enableNavigationPreload());\r\n    return self.clients.claim();\r\n  }\r\n\r\n  /**\r\n   *  {type: 'NOTIFICATION', data: {title, body, icon, actions}}\r\n   *  {type: 'NOTIFICATION_WAITING'}\r\n   */\r\n  #onPush(event) {\r\n    const me = this;\r\n    me.trace('Push message received:', event);\r\n\r\n    // format {type, data}\r\n    const payload = event.data?.json();\r\n    let options = null;\r\n\r\n    if (payload?.type === 'NOTIFICATION') {\r\n      options = payload?.data;\r\n    }\r\n\r\n    if (payload?.type === 'NOTIFICATION_WAITING') {\r\n      options = me.#notificationOptions;\r\n    }\r\n\r\n    if (options) {\r\n      //event.waitUntil(me.#handleNotification(me.#notificationOptions));\r\n      me.#handleNotification(me.#notificationOptions);\r\n    }\r\n  }\r\n\r\n  #onSync(event) {\r\n    this.trace('Sync message received:', event);\r\n  }\r\n\r\n  /**\r\n   * Intercept fetch events and respond with cached resources if they match the filter.\r\n   * @param {*} event \r\n   * @returns \r\n   */\r\n  #onFetch(event) {\r\n    const me = this;\r\n\r\n    // Check if the request matches any filter\r\n    if (!me.#filter.match(event.request)) {\r\n      me.trace('Fetch filter skip for:', event.request.url);  \r\n      return;\r\n    } \r\n    \r\n    me.trace('Fetch event for:', event.request.url);\r\n\r\n    event.respondWith(\r\n      me.#cache.cacheFirst(event.request, event)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients based on message channel.\r\n   * @param {*} event \r\n   */\r\n  #onPortMessage(event) {\r\n    if (this.#trace) {\r\n      me.trace('Client message received on port:', event);\r\n      event.target?.postMessage(`Hi client: ${event.data} from Service Worker Port2`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients or other sources.\r\n   * This method is called when a message is received by the service worker.\r\n   * @param {MessageEvent} event \r\n   */\r\n  #onMessage(event) {\r\n    const me = this;\r\n    if (me.#isSelf(event)) return;\r\n\r\n    me.#handleTrace(event);\r\n\r\n    // handle worker update\r\n    if (event.data === 'SKIP_WAITING') {\r\n      return self.skipWaiting();\r\n    }\r\n\r\n    if (event.data === 'CLEAR_CACHE') {\r\n      event.waitUntil( me.#cache.clearCache() );\r\n      return;\r\n    }\r\n\r\n    // handle worker update notification\r\n    if (event.data === 'NOTIFICATION_WAITING') {\r\n      event.waitUntil(\r\n        me.#handleNotification(me.#notificationOptions)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (me.#handleChannel(event)) return;\r\n\r\n    // TODO: Handle other message types\r\n\r\n  }\r\n\r\n  #onMessageError(event) {\r\n    this.#trace(\"Message deserialization failed:\", event);\r\n  }\r\n\r\n  async #onNotification(event) {\r\n    //const payload = event.notification.data;\r\n    if (event.action === 'refresh') {\r\n      this.trace('Notification action: Refresh');\r\n      self.registration?.waiting?.postMessage('SKIP_WAITING');\r\n      /*\r\n      const clients =  await self.clients.matchAll();\r\n      clients.forEach(client => client.navigate(client.url));\r\n      */\r\n    }\r\n  }\r\n\r\n  // Check if the event source is the service worker itself\r\n  #isSelf(event) {\r\n    return event.source === self.serviceWorker;\r\n  }\r\n\r\n  // Enable navigation preload\r\n  async #enableNavigationPreload() {\r\n    if (self.registration.navigationPreload) {\r\n      await self.registration.navigationPreload.enable();\r\n    }\r\n  }\r\n\r\n  #handleTrace(event) {\r\n    const me = this;\r\n    if (event?.data === 'TRACE_ON') {\r\n      me.#trace = true;\r\n      console.log('Service Worker trace enabled');\r\n    } else if (event?.data === 'TRACE_OFF') {\r\n      me.#trace = false;\r\n      console.log('Service Worker trace disabled');\r\n    }\r\n\r\n    if (me.#trace) {\r\n      me.trace('Service Worker message received:', event);\r\n      // \r\n      event.source?.postMessage(`Hi client: ${event.data} from Service Worker`);\r\n    }\r\n  }\r\n\r\n  #handleChannel(event) {\r\n    const me = this;\r\n    if (event?.data === 'INIT_PORT' && event?.ports[0]) {\r\n      me.trace('Client port init :', event);\r\n      event.ports[0].onmessage = me.#onPortMessage.bind(me);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  async #handleNotification(options) {\r\n    const me = this;\r\n    me.trace('Notification received:', options);\r\n    if (options) {\r\n      return self.registration.showNotification(options.title, options);\r\n    }\r\n  }\r\n\r\n  trace(message, data = '') {\r\n    if (this.#trace) {\r\n      console.log(message, data);\r\n    }\r\n  }\r\n\r\n  static create(options) {\r\n    return new WorkerEngine(options);\r\n  }\r\n}"],"names":["CacheEngine","name","constructor","self","Error","this","async","caches","open","resources","init","addAll","request","response","put","match","event","me","fetchedResponse","fetch","ok","waitUntil","putInCache","clone","responseFromCache","getFromCache","preloadResponse","fetchAndCache","cache","keys","then","Promise","all","map","key","delete","FilterEngine","filters","Map","registerAll","filter","rule","RegExp","fn","register","regexFilter","parsed","lastIndex","test","URL","parse","url","pathname","toLowerCase","has","set","unregister","entries","WorkerEngine","trace","options","notificationOptions","title","body","requireInteraction","actions","action","data","cacheName","addEventListener","onInstall","bind","onActivate","onPush","onSync","onFetch","onMessage","onMessageError","onNotification","preCacheURL","filesToCache","json","addResourcesToCache","precachedAssets","precacheURL","precacheAssets","precache","preload","enableNavigationPreload","clients","claim","payload","type","handleNotification","respondWith","cacheFirst","onPortMessage","target","postMessage","isSelf","handleTrace","skipWaiting","handleChannel","clearCache","registration","waiting","source","serviceWorker","navigationPreload","enable","ports","onmessage","showNotification","message","static"],"mappings":"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"}