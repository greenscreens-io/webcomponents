{"version":3,"file":"io.greenscreens.worker.min.js","sources":["../../modules/worker/Cache.mjs","../../modules/worker/Filter.mjs","../../modules/worker/Worker.mjs"],"sourcesContent":["/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\n/**\r\n * CacheEngine class provides a simple interface to manage caching of resources using the Cache API.\r\n */\r\nexport class CacheEngine {\r\n\r\n  #name;\r\n\r\n  /**\r\n   * Creates an instance of CacheEngine with a specified cache name.\r\n   * @param {*} name \r\n   */\r\n  constructor(name) {\r\n    if (!('caches' in self)) {\r\n      throw new Error('Cache API is not supported in this browser.');     \r\n    }\r\n    this.#name = name || 'DefaultCache';\r\n  }\r\n\r\n  /**\r\n   * Returns the name of the cache.\r\n   */\r\n  get name() {\r\n    return this.#name;\r\n  }\r\n  \r\n  /**\r\n   * Initialize the cache engine.\r\n   * This should be called first before using the cahe engine.\r\n   * @returns \r\n   */\r\n  async init() {  \r\n    return caches.open(this.#name);\r\n  }\r\n\r\n  /**\r\n   * Add resources to cache.\r\n   * @param {*} resources \r\n   * @returns \r\n   */\r\n  async addResourcesToCache(resources) {\r\n    const cache = await this.init(); \r\n    return cache.addAll(resources);\r\n  }\r\n\r\n  /**\r\n   * Put the response in cache for the given request.\r\n   * @param {*} request \r\n   * @param {*} response \r\n   * @returns \r\n   */\r\n  async putInCache(request, response) {\r\n    const cache = await this.init();\r\n    return cache.put(request, response);\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache for the given request.\r\n   * @param {*} request \r\n   * @returns \r\n   */\r\n  async getFromCache(request) {\r\n    const cache = await this.init();\r\n    return cache.match(request);\r\n  }\r\n\r\n  async #store(request, response, event) {\r\n      const me = this;\r\n      if (event) {\r\n        event.waitUntil(me.putInCache(request, response.clone()));\r\n      } else {\r\n        await me.putInCache(request, response.clone());\r\n      }\r\n  }\r\n\r\n  /**\r\n   * Fetch resource from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @param {*} event\r\n   * @returns \r\n   */\r\n  async fetchAndCache(request, event) { \r\n    const me = this;\r\n    const fetchedResponse = await fetch(request);\r\n    if (fetchedResponse.ok) {\r\n      await me.#store(request, fetchedResponse);\r\n    }\r\n    return fetchedResponse;\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache first, if not found, \r\n   * fetch it from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @param {*} event \r\n   * @returns Promise<Response>\r\n   */\r\n  async cacheFirst(request, event) {\r\n    const me = this;\r\n\r\n    // Try to get the request from cache first\r\n    const responseFromCache = await me.getFromCache(request);\r\n    if (responseFromCache) return responseFromCache;\r\n    \r\n    // Next try to use (and cache) the preloaded response, if it's there\r\n    const preloadResponse = await event?.preloadResponse;\r\n    if (preloadResponse) {\r\n      await me.#store(request, fetchedResponse);\r\n      return preloadResponse;\r\n    }    \r\n\r\n    // Finally, fetch from network and cache the response\r\n    return me.fetchAndCache(request, event);\r\n  }\r\n\r\n  async clearCache() {\r\n    const cache = await this.init();\r\n    return cache.keys().then(keys => {\r\n      return Promise.all(keys.map(key => cache.delete(key)));\r\n    }); \r\n  }\r\n\r\n}","/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\n/**\r\n * FilterEngine class provides a simple interface to manage filters for fetch requests.\r\n * It allows registering and unregistering functions that can be used to match requests against specific criteria.\r\n */\r\nexport class FilterEngine {\r\n\r\n  #filters = new Map();\r\n  #ignores = new Map();\r\n\r\n  constructor(filters, nocache) {\r\n    this.registerAll(filters);\r\n  }\r\n\r\n  registerAll(filters = []) {\r\n    const me = this;\r\n    for (const filter of filters) {\r\n      if (typeof filter.name !== 'string') {\r\n        console.warn('Invalid filter format. Expected { name: string, fn: function }');\r\n        continue;\r\n      }\r\n\r\n      if (typeof filter.rule === 'string') {\r\n        filter.rule = new RegExp(filter.rule);\r\n      }\r\n\r\n      if (filter.fn) {\r\n        me.register(filter.name, filter.fn, filter.ignore);\r\n      } else if (filter.rule instanceof RegExp) {\r\n        me.register(filter.name, me.#regexFilter(filter), filter.ignore);\r\n      }\r\n    }\r\n  }\r\n\r\n  #regexFilter(filter) {\r\n    const rule = filter.rule;\r\n    const parsed = filter.parsed ? true : false;\r\n    return (request) => {\r\n      rule.lastIndex = 0;\r\n      return parsed ?\r\n        rule.test(URL.parse(request.url).pathname.toLowerCase())\r\n        :\r\n        rule.test(request.url.toLowerCase());\r\n    };\r\n  }\r\n\r\n  register(name, filter, ignore = false) {\r\n    const me = this;\r\n    if (me.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} already exists.`);\r\n      return;\r\n    }\r\n    if (ignore) {\r\n      me.#ignores.set(name, filter);\r\n    } else {\r\n      me.#filters.set(name, filter);\r\n    }\r\n  }\r\n\r\n  unregister(name) {\r\n    const me = this;\r\n    if (!me.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} does not exist.`);\r\n      return;\r\n    }\r\n    me.#filters.delete(name);\r\n  }\r\n\r\n  match(request) {\r\n\r\n    for (const filter of this.#ignores.values()) {\r\n      if (filter(request)) {\r\n        return false; \r\n      }\r\n    }\r\n\r\n    for (const filter of this.#filters.values()) {\r\n      if (filter(request)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\nimport { FilterEngine } from \"./Filter.mjs\";\r\nimport { CacheEngine } from \"./Cache.mjs\";\r\n\r\n// https://github.com/mdn/serviceworker-cookbook\r\n\r\n/**\r\n * WorkerEngine class provides a simple interface to manage service worker lifecycle events,\r\n * caching strategies, and push notifications.\r\n */\r\nexport class WorkerEngine {\r\n\r\n  #trace = false;\r\n  #options = null;\r\n  #filter = null;\r\n  #cache = null;\r\n\r\n  #notificationOptions = {\r\n    title: \"Refresh now?\",\r\n    body: \"New version of the app is available.\",\r\n    requireInteraction: true,\r\n    actions: [\r\n      { action: 'refresh', title: 'Refresh' },\r\n      { action: 'cancel', title: 'Cancel' }\r\n    ],\r\n    data: {}\r\n  };\r\n\r\n  constructor(options) {\r\n    const me = this;\r\n    me.#options = options || {};\r\n    me.#trace = options?.trace || false;\r\n    me.#filter = new FilterEngine(options?.filters || []);\r\n    me.#cache = new CacheEngine(options?.cacheName || 'DefaultCache');\r\n    self.addEventListener('install', me.#onInstall.bind(me));\r\n    self.addEventListener('activate', me.#onActivate.bind(me));\r\n    self.addEventListener('push', me.#onPush.bind(me));\r\n    self.addEventListener('sync', me.#onSync.bind(me));\r\n    self.addEventListener('fetch', me.#onFetch.bind(me));\r\n    self.addEventListener('message', me.#onMessage.bind(me));\r\n    self.addEventListener('messageerror', me.#onMessageError.bind(me));\r\n    self.addEventListener('notificationclick', me.#onNotification.bind(me));\r\n  }\r\n\r\n  async #precacheURL() {\r\n    const me = this;\r\n    if (me.#options?.preCacheURL) {\r\n      me.trace('Precached JSON definition:', me.#options?.preCacheURL);\r\n      const response = await fetch(me.#options.preCacheURL);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to fetch precache URL: ${me.#options.preCacheURL}`);\r\n      }\r\n      const filesToCache = await response.json();\r\n      me.trace('Precached files:', filesToCache);\r\n      await me.#cache.addResourcesToCache(filesToCache);\r\n    }\r\n  }\r\n\r\n  async #precacheAssets() {\r\n    const me = this;\r\n    if (me.#options?.precachedAssets) {\r\n      me.trace('Precached assets:', me.#options?.precachedAssets);\r\n      await me.#cache.addResourcesToCache(me.#options.precachedAssets)\r\n    }\r\n  }\r\n\r\n  async #precache() {\r\n    const me = this;\r\n    await me.#precacheURL();\r\n    await me.#precacheAssets();\r\n  }\r\n\r\n  #onInstall(event) {\r\n    const me = this;\r\n    me.trace('Service Worker installing:', event);\r\n    event.waitUntil(me.#precache());\r\n  }\r\n\r\n  #onActivate(event) {\r\n    const me = this;\r\n    me.trace('Service Worker activated:', event);\r\n    if (me.#options?.preload) event.waitUntil(me.#enableNavigationPreload());\r\n    return self.clients.claim();\r\n  }\r\n\r\n  /**\r\n   *  {type: 'NOTIFICATION', data: {title, body, icon, actions}}\r\n   *  {type: 'NOTIFICATION_WAITING'}\r\n   */\r\n  #onPush(event) {\r\n    const me = this;\r\n    me.trace('Push message received:', event);\r\n\r\n    // format {type, data}\r\n    const payload = event.data?.json();\r\n    let options = null;\r\n\r\n    if (payload?.type === 'NOTIFICATION') {\r\n      options = payload?.data;\r\n    }\r\n\r\n    if (payload?.type === 'NOTIFICATION_WAITING') {\r\n      options = me.#notificationOptions;\r\n    }\r\n\r\n    if (options) {\r\n      //event.waitUntil(me.#handleNotification(me.#notificationOptions));\r\n      me.#handleNotification(me.#notificationOptions);\r\n    }\r\n  }\r\n\r\n  #onSync(event) {\r\n    this.trace('Sync message received:', event);\r\n  }\r\n\r\n  /**\r\n   * Intercept fetch events and respond with cached resources if they match the filter.\r\n   * @param {*} event \r\n   * @returns \r\n   */\r\n  #onFetch(event) {\r\n    const me = this;\r\n\r\n    // Check if the request matches any filter\r\n    if (!me.#filter.match(event.request)) {\r\n      me.trace('Fetch filter skip for:', event.request.url);  \r\n      return;\r\n    } \r\n    \r\n    me.trace('Fetch event for:', event.request.url);\r\n\r\n    event.respondWith(\r\n      me.#cache.cacheFirst(event.request, event)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients based on message channel.\r\n   * @param {*} event \r\n   */\r\n  #onPortMessage(event) {\r\n    if (this.#trace) {\r\n      me.trace('Client message received on port:', event);\r\n      event.target?.postMessage(`Hi client: ${event.data} from Service Worker Port2`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients or other sources.\r\n   * This method is called when a message is received by the service worker.\r\n   * @param {MessageEvent} event \r\n   */\r\n  #onMessage(event) {\r\n    const me = this;\r\n    if (me.#isSelf(event)) return;\r\n\r\n    me.#handleTrace(event);\r\n\r\n    // handle worker update\r\n    if (event.data === 'SKIP_WAITING') {\r\n      return self.skipWaiting();\r\n    }\r\n\r\n    if (event.data === 'CLEAR_CACHE') {\r\n      event.waitUntil( me.#cache.clearCache() );\r\n      return;\r\n    }\r\n\r\n    if (event.data === 'REFRESH_CACHE') {\r\n      event.waitUntil( me.#precacheURL());\r\n      return;\r\n    }\r\n    \r\n\r\n    // handle worker update notification\r\n    if (event.data === 'NOTIFICATION_WAITING') {\r\n      event.waitUntil(\r\n        me.#handleNotification(me.#notificationOptions)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (me.#handleChannel(event)) return;\r\n\r\n    // TODO: Handle other message types\r\n\r\n  }\r\n\r\n  #onMessageError(event) {\r\n    this.#trace(\"Message deserialization failed:\", event);\r\n  }\r\n\r\n  async #onNotification(event) {\r\n    //const payload = event.notification.data;\r\n    if (event.action === 'refresh') {\r\n      this.trace('Notification action: Refresh');\r\n      self.registration?.waiting?.postMessage('SKIP_WAITING');\r\n      /*\r\n      const clients =  await self.clients.matchAll();\r\n      clients.forEach(client => client.navigate(client.url));\r\n      */\r\n    }\r\n  }\r\n\r\n  // Check if the event source is the service worker itself\r\n  #isSelf(event) {\r\n    return event.source === self.serviceWorker;\r\n  }\r\n\r\n  // Enable navigation preload\r\n  async #enableNavigationPreload() {\r\n    if (self.registration.navigationPreload) {\r\n      await self.registration.navigationPreload.enable();\r\n    }\r\n  }\r\n\r\n  #handleTrace(event) {\r\n    const me = this;\r\n    if (event?.data === 'TRACE_ON') {\r\n      me.#trace = true;\r\n      console.warn('Service Worker trace enabled');\r\n    } else if (event?.data === 'TRACE_OFF') {\r\n      me.#trace = false;\r\n      console.warn('Service Worker trace disabled');\r\n    }\r\n\r\n    if (me.#trace) {\r\n      me.trace('Service Worker message received:', event);\r\n      // \r\n      event.source?.postMessage(`Hi client: ${event.data} from Service Worker`);\r\n    }\r\n  }\r\n\r\n  #handleChannel(event) {\r\n    const me = this;\r\n    if (event?.data === 'INIT_PORT' && event?.ports[0]) {\r\n      me.trace('Client port init :', event);\r\n      event.ports[0].onmessage = me.#onPortMessage.bind(me);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  async #handleNotification(options) {\r\n    const me = this;\r\n    me.trace('Notification received:', options);\r\n    if (options) {\r\n      return self.registration.showNotification(options.title, options);\r\n    }\r\n  }\r\n\r\n  trace(message, data = '') {\r\n    if (this.#trace) {\r\n      console.trace(message, data);\r\n    }\r\n  }\r\n\r\n  static create(options) {\r\n    return new WorkerEngine(options);\r\n  }\r\n}"],"names":["CacheEngine","name","constructor","self","Error","this","async","caches","open","resources","init","addAll","request","response","put","match","event","me","waitUntil","putInCache","clone","fetchedResponse","fetch","ok","store","responseFromCache","getFromCache","preloadResponse","fetchAndCache","cache","keys","then","Promise","all","map","key","delete","FilterEngine","filters","Map","ignores","nocache","registerAll","filter","rule","RegExp","fn","register","ignore","regexFilter","parsed","lastIndex","test","URL","parse","url","pathname","toLowerCase","has","set","unregister","values","WorkerEngine","trace","options","notificationOptions","title","body","requireInteraction","actions","action","data","cacheName","addEventListener","onInstall","bind","onActivate","onPush","onSync","onFetch","onMessage","onMessageError","onNotification","preCacheURL","filesToCache","json","addResourcesToCache","precachedAssets","precacheURL","precacheAssets","precache","preload","enableNavigationPreload","clients","claim","payload","type","handleNotification","respondWith","cacheFirst","onPortMessage","target","postMessage","isSelf","handleTrace","skipWaiting","handleChannel","clearCache","registration","waiting","source","serviceWorker","navigationPreload","enable","ports","onmessage","showNotification","message","static"],"mappings":"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"}