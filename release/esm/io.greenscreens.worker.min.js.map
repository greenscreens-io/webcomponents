{"version":3,"file":"io.greenscreens.worker.min.js","names":["#name","#store","me","fetchedResponse","me","#regexFilter","#filters","#ignores","me","#options","#trace","#filter","#cache","#onInstall","#onActivate","#onPush","#onSync","#onFetch","#onMessage","#onMessageError","#onNotification","#precacheURL","#precacheAssets","#precache","#enableNavigationPreload","#notificationOptions","#handleNotification","#isSelf","#handleTrace","#handleChannel","#onPortMessage"],"sources":["../../modules/worker/Cache.mjs","../../modules/worker/Filter.mjs","../../modules/worker/Worker.mjs"],"sourcesContent":["/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\n/**\r\n * CacheEngine class provides a simple interface to manage caching of resources using the Cache API.\r\n */\r\nexport class CacheEngine {\r\n\r\n  #name;\r\n\r\n  /**\r\n   * Creates an instance of CacheEngine with a specified cache name.\r\n   * @param {*} name \r\n   */\r\n  constructor(name) {\r\n    if (!('caches' in self)) {\r\n      throw new Error('Cache API is not supported in this browser.');     \r\n    }\r\n    this.#name = name || 'DefaultCache';\r\n  }\r\n\r\n  /**\r\n   * Returns the name of the cache.\r\n   */\r\n  get name() {\r\n    return this.#name;\r\n  }\r\n  \r\n  /**\r\n   * Initialize the cache engine.\r\n   * This should be called first before using the cahe engine.\r\n   * @returns \r\n   */\r\n  async init() {  \r\n    return caches.open(this.#name);\r\n  }\r\n\r\n  /**\r\n   * Add resources to cache.\r\n   * @param {*} resources \r\n   * @returns \r\n   */\r\n  async addResourcesToCache(resources) {\r\n    const cache = await this.init(); \r\n    return cache.addAll(resources);\r\n  }\r\n\r\n  /**\r\n   * Put the response in cache for the given request.\r\n   * @param {*} request \r\n   * @param {*} response \r\n   * @returns \r\n   */\r\n  async putInCache(request, response) {\r\n    const cache = await this.init();\r\n    return cache.put(request, response);\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache for the given request.\r\n   * @param {*} request \r\n   * @returns \r\n   */\r\n  async getFromCache(request) {\r\n    const cache = await this.init();\r\n    return cache.match(request);\r\n  }\r\n\r\n  async #store(request, response, event) {\r\n      const me = this;\r\n      if (event) {\r\n        event.waitUntil(me.putInCache(request, response.clone()));\r\n      } else {\r\n        await me.putInCache(request, response.clone());\r\n      }\r\n  }\r\n\r\n  /**\r\n   * Fetch resource from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @param {*} event\r\n   * @returns \r\n   */\r\n  async fetchAndCache(request, event) { \r\n    const me = this;\r\n    const fetchedResponse = await fetch(request);\r\n    if (fetchedResponse.ok) {\r\n      await me.#store(request, fetchedResponse);\r\n    }\r\n    return fetchedResponse;\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache first, if not found, \r\n   * fetch it from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @param {*} event \r\n   * @returns Promise<Response>\r\n   */\r\n  async cacheFirst(request, event) {\r\n    const me = this;\r\n\r\n    // Try to get the request from cache first\r\n    const responseFromCache = await me.getFromCache(request);\r\n    if (responseFromCache) return responseFromCache;\r\n    \r\n    // Next try to use (and cache) the preloaded response, if it's there\r\n    const preloadResponse = await event?.preloadResponse;\r\n    if (preloadResponse) {\r\n      await me.#store(request, fetchedResponse);\r\n      return preloadResponse;\r\n    }    \r\n\r\n    // Finally, fetch from network and cache the response\r\n    return me.fetchAndCache(request, event);\r\n  }\r\n\r\n  async clearCache() {\r\n    const cache = await this.init();\r\n    return cache.keys().then(keys => {\r\n      return Promise.all(keys.map(key => cache.delete(key)));\r\n    }); \r\n  }\r\n\r\n}","/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\n/**\r\n * FilterEngine class provides a simple interface to manage filters for fetch requests.\r\n * It allows registering and unregistering functions that can be used to match requests against specific criteria.\r\n */\r\nexport class FilterEngine {\r\n\r\n  #filters = new Map();\r\n  #ignores = new Map();\r\n\r\n  constructor(filters, nocache) {\r\n    this.registerAll(filters);\r\n  }\r\n\r\n  registerAll(filters = []) {\r\n    const me = this;\r\n    for (const filter of filters) {\r\n      if (typeof filter.name !== 'string') {\r\n        console.warn('Invalid filter format. Expected { name: string, fn: function }');\r\n        continue;\r\n      }\r\n\r\n      if (typeof filter.rule === 'string') {\r\n        filter.rule = new RegExp(filter.rule);\r\n      }\r\n\r\n      if (filter.fn) {\r\n        me.register(filter.name, filter.fn, filter.ignore);\r\n      } else if (filter.rule instanceof RegExp) {\r\n        me.register(filter.name, me.#regexFilter(filter), filter.ignore);\r\n      }\r\n    }\r\n  }\r\n\r\n  #regexFilter(filter) {\r\n    const rule = filter.rule;\r\n    const parsed = filter.parsed ? true : false;\r\n    return (request) => {\r\n      rule.lastIndex = 0;\r\n      return parsed ?\r\n        rule.test(URL.parse(request.url).pathname.toLowerCase())\r\n        :\r\n        rule.test(request.url.toLowerCase());\r\n    };\r\n  }\r\n\r\n  register(name, filter, ignore = false) {\r\n    const me = this;\r\n    if (me.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} already exists.`);\r\n      return;\r\n    }\r\n    if (ignore) {\r\n      me.#ignores.set(name, filter);\r\n    } else {\r\n      me.#filters.set(name, filter);\r\n    }\r\n  }\r\n\r\n  unregister(name) {\r\n    const me = this;\r\n    if (!me.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} does not exist.`);\r\n      return;\r\n    }\r\n    me.#filters.delete(name);\r\n  }\r\n\r\n  match(request) {\r\n\r\n    for (const filter of this.#ignores.values()) {\r\n      if (filter(request)) {\r\n        return false; \r\n      }\r\n    }\r\n\r\n    for (const filter of this.#filters.values()) {\r\n      if (filter(request)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","/*\r\n * Copyright (C) 2015, 2025; Green Screens Ltd.\r\n */\r\n\r\nimport { FilterEngine } from \"./Filter.mjs\";\r\nimport { CacheEngine } from \"./Cache.mjs\";\r\n\r\n// https://github.com/mdn/serviceworker-cookbook\r\n\r\n/**\r\n * WorkerEngine class provides a simple interface to manage service worker lifecycle events,\r\n * caching strategies, and push notifications.\r\n */\r\nexport class WorkerEngine {\r\n\r\n  #trace = false;\r\n  #options = null;\r\n  #filter = null;\r\n  #cache = null;\r\n\r\n  #notificationOptions = {\r\n    title: \"Refresh now?\",\r\n    body: \"New version of the app is available.\",\r\n    requireInteraction: true,\r\n    actions: [\r\n      { action: 'refresh', title: 'Refresh' },\r\n      { action: 'cancel', title: 'Cancel' }\r\n    ],\r\n    data: {}\r\n  };\r\n\r\n  constructor(options) {\r\n    const me = this;\r\n    me.#options = options || {};\r\n    me.#trace = options?.trace || false;\r\n    me.#filter = new FilterEngine(options?.filters || []);\r\n    me.#cache = new CacheEngine(options?.cacheName || 'DefaultCache');\r\n    self.addEventListener('install', me.#onInstall.bind(me));\r\n    self.addEventListener('activate', me.#onActivate.bind(me));\r\n    self.addEventListener('push', me.#onPush.bind(me));\r\n    self.addEventListener('sync', me.#onSync.bind(me));\r\n    self.addEventListener('fetch', me.#onFetch.bind(me));\r\n    self.addEventListener('message', me.#onMessage.bind(me));\r\n    self.addEventListener('messageerror', me.#onMessageError.bind(me));\r\n    self.addEventListener('notificationclick', me.#onNotification.bind(me));\r\n  }\r\n\r\n  async #precacheURL() {\r\n    const me = this;\r\n    if (me.#options?.preCacheURL) {\r\n      me.trace('Precached JSON definition:', me.#options?.preCacheURL);\r\n      const response = await fetch(me.#options.preCacheURL);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to fetch precache URL: ${me.#options.preCacheURL}`);\r\n      }\r\n      const filesToCache = await response.json();\r\n      me.trace('Precached files:', filesToCache);\r\n      await me.#cache.addResourcesToCache(filesToCache);\r\n    }\r\n  }\r\n\r\n  async #precacheAssets() {\r\n    const me = this;\r\n    if (me.#options?.precachedAssets) {\r\n      me.trace('Precached assets:', me.#options?.precachedAssets);\r\n      await me.#cache.addResourcesToCache(me.#options.precachedAssets)\r\n    }\r\n  }\r\n\r\n  async #precache() {\r\n    const me = this;\r\n    await me.#precacheURL();\r\n    await me.#precacheAssets();\r\n  }\r\n\r\n  #onInstall(event) {\r\n    const me = this;\r\n    me.trace('Service Worker installing:', event);\r\n    event.waitUntil(me.#precache());\r\n  }\r\n\r\n  #onActivate(event) {\r\n    const me = this;\r\n    me.trace('Service Worker activated:', event);\r\n    if (me.#options?.preload) event.waitUntil(me.#enableNavigationPreload());\r\n    return self.clients.claim();\r\n  }\r\n\r\n  /**\r\n   *  {type: 'NOTIFICATION', data: {title, body, icon, actions}}\r\n   *  {type: 'NOTIFICATION_WAITING'}\r\n   */\r\n  #onPush(event) {\r\n    const me = this;\r\n    me.trace('Push message received:', event);\r\n\r\n    // format {type, data}\r\n    const payload = event.data?.json();\r\n    let options = null;\r\n\r\n    if (payload?.type === 'NOTIFICATION') {\r\n      options = payload?.data;\r\n    }\r\n\r\n    if (payload?.type === 'NOTIFICATION_WAITING') {\r\n      options = me.#notificationOptions;\r\n    }\r\n\r\n    if (options) {\r\n      //event.waitUntil(me.#handleNotification(me.#notificationOptions));\r\n      me.#handleNotification(me.#notificationOptions);\r\n    }\r\n  }\r\n\r\n  #onSync(event) {\r\n    this.trace('Sync message received:', event);\r\n  }\r\n\r\n  /**\r\n   * Intercept fetch events and respond with cached resources if they match the filter.\r\n   * @param {*} event \r\n   * @returns \r\n   */\r\n  #onFetch(event) {\r\n    \r\n    const me = this;\r\n\r\n    // Check if the request matches any filter\r\n    const isOk = me.#filter.match(event.request);\r\n\r\n    if (isOk) {\r\n      me.trace('Fetch event for:', event.request.url);\r\n      event.respondWith(\r\n        me.#cache.cacheFirst(event.request, event)\r\n      );      \r\n    }  else {\r\n      me.trace('Fetch filter skip for:', event.request.url);  \r\n    }\r\n    \r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients based on message channel.\r\n   * @param {*} event \r\n   */\r\n  #onPortMessage(event) {\r\n    if (this.#trace) {\r\n      me.trace('Client message received on port:', event);\r\n      event.target?.postMessage(`Hi client: ${event.data} from Service Worker Port2`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients or other sources.\r\n   * This method is called when a message is received by the service worker.\r\n   * @param {MessageEvent} event \r\n   */\r\n  #onMessage(event) {\r\n    const me = this;\r\n    if (me.#isSelf(event)) return;\r\n\r\n    me.#handleTrace(event);\r\n\r\n    // handle worker update\r\n    if (event.data === 'SKIP_WAITING') {\r\n      return self.skipWaiting();\r\n    }\r\n\r\n    if (event.data === 'CLEAR_CACHE') {\r\n      event.waitUntil( me.#cache.clearCache() );\r\n      return;\r\n    }\r\n\r\n    if (event.data === 'REFRESH_CACHE') {\r\n      event.waitUntil( me.#precacheURL());\r\n      return;\r\n    }\r\n    \r\n\r\n    // handle worker update notification\r\n    if (event.data === 'NOTIFICATION_WAITING') {\r\n      event.waitUntil(\r\n        me.#handleNotification(me.#notificationOptions)\r\n      );\r\n      return;\r\n    }\r\n\r\n    if (me.#handleChannel(event)) return;\r\n\r\n    // TODO: Handle other message types\r\n\r\n  }\r\n\r\n  #onMessageError(event) {\r\n    this.#trace(\"Message deserialization failed:\", event);\r\n  }\r\n\r\n  async #onNotification(event) {\r\n    //const payload = event.notification.data;\r\n    if (event.action === 'refresh') {\r\n      this.trace('Notification action: Refresh');\r\n      self.registration?.waiting?.postMessage('SKIP_WAITING');\r\n      /*\r\n      const clients =  await self.clients.matchAll();\r\n      clients.forEach(client => client.navigate(client.url));\r\n      */\r\n    }\r\n  }\r\n\r\n  // Check if the event source is the service worker itself\r\n  #isSelf(event) {\r\n    return event.source === self.serviceWorker;\r\n  }\r\n\r\n  // Enable navigation preload\r\n  async #enableNavigationPreload() {\r\n    if (self.registration.navigationPreload) {\r\n      await self.registration.navigationPreload.enable();\r\n    }\r\n  }\r\n\r\n  #handleTrace(event) {\r\n    const me = this;\r\n    if (event?.data === 'TRACE_ON') {\r\n      me.#trace = true;\r\n      console.warn('Service Worker trace enabled');\r\n    } else if (event?.data === 'TRACE_OFF') {\r\n      me.#trace = false;\r\n      console.warn('Service Worker trace disabled');\r\n    }\r\n\r\n    if (me.#trace) {\r\n      me.trace('Service Worker message received:', event);\r\n      // \r\n      event.source?.postMessage(`Hi client: ${event.data} from Service Worker`);\r\n    }\r\n  }\r\n\r\n  #handleChannel(event) {\r\n    const me = this;\r\n    if (event?.data === 'INIT_PORT' && event?.ports[0]) {\r\n      me.trace('Client port init :', event);\r\n      event.ports[0].onmessage = me.#onPortMessage.bind(me);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  async #handleNotification(options) {\r\n    const me = this;\r\n    me.trace('Notification received:', options);\r\n    if (options) {\r\n      return self.registration.showNotification(options.title, options);\r\n    }\r\n  }\r\n\r\n  trace(message, data = '') {\r\n    if (this.#trace) {\r\n      console.trace(message, data);\r\n    }\r\n  }\r\n\r\n  static create(options) {\r\n    return new WorkerEngine(options);\r\n  }\r\n}"],"mappings":"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"}