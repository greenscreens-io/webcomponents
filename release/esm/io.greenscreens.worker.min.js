class CacheEngine{#e;constructor(e){if(!('caches'in self))throw new Error('Cache API is not supported in this browser.');this.#e=e||'DefaultCache'}get name(){return this.#e}async init(){return caches.open(this.#e)}async addResourcesToCache(e){return(await this.init()).addAll(e)}async putInCache(e,t){return(await this.init()).put(e,t)}async getFromCache(e){return(await this.init()).match(e)}async#t(e,t,a){const n=this;a?a.waitUntil(n.putInCache(e,t.clone())):await n.putInCache(e,t.clone())}async fetchAndCache(e,t){const a=this,n=await fetch(e);return n.ok&&await a.#t(e,n),n}async cacheFirst(e,t){const a=this,n=await a.getFromCache(e);if(n)return n;const i=await(t?.preloadResponse);return i?(await a.#t(e,fetchedResponse),i):a.fetchAndCache(e,t)}async clearCache(){const e=await this.init();return e.keys().then((t=>Promise.all(t.map((t=>e.delete(t))))))}}class FilterEngine{#a=new Map;#n=new Map;constructor(e,t){this.registerAll(e)}registerAll(e=[]){const t=this;for(const a of e)'string'==typeof a.name?('string'==typeof a.rule&&(a.rule=new RegExp(a.rule)),a.fn?t.register(a.name,a.fn,a.ignore):a.rule instanceof RegExp&&t.register(a.name,t.#i(a),a.ignore)):console.warn('Invalid filter format. Expected { name: string, fn: function }')}#i(e){const t=e.rule,a=!!e.parsed;return e=>(t.lastIndex=0,a?t.test(URL.parse(e.url).pathname.toLowerCase()):t.test(e.url.toLowerCase()))}register(e,t,a=!1){const n=this;n.#a.has(e)?console.warn(`Filter with name ${e} already exists.`):a?n.#n.set(e,t):n.#a.set(e,t)}unregister(e){this.#a.has(e)?this.#a.delete(e):console.warn(`Filter with name ${e} does not exist.`)}match(e){for(const t of this.#n.values())if(t(e))return!1;for(const t of this.#a.values())if(t(e))return!0;return!1}}class WorkerEngine{#s=!1;#r=null;#c=null;#o=null;#l={title:'Refresh now?',body:'New version of the app is available.',requireInteraction:!0,actions:[{action:'refresh',title:'Refresh'},{action:'cancel',title:'Cancel'}],data:{}};constructor(e){const t=this;t.#r=e||{},t.#s=e?.trace||!1,t.#c=new FilterEngine(e?.filters||[]),t.#o=new CacheEngine(e?.cacheName||'DefaultCache'),self.addEventListener('install',t.#h.bind(t)),self.addEventListener('activate',t.#d.bind(t)),self.addEventListener('push',t.#f.bind(t)),self.addEventListener('sync',t.#p.bind(t)),self.addEventListener('fetch',t.#u.bind(t)),self.addEventListener('message',t.#g.bind(t)),self.addEventListener('messageerror',t.#w.bind(t)),self.addEventListener('notificationclick',t.#C.bind(t))}async#v(){const e=this;if(e.#r?.preCacheURL){e.trace('Precached JSON definition:',e.#r?.preCacheURL);const t=await fetch(e.#r.preCacheURL);if(!t.ok)throw new Error(`Failed to fetch precache URL: ${e.#r.preCacheURL}`);const a=await t.json();e.trace('Precached files:',a),await e.#o.addResourcesToCache(a)}}async#m(){const e=this;e.#r?.precachedAssets&&(e.trace('Precached assets:',e.#r?.precachedAssets),await e.#o.addResourcesToCache(e.#r.precachedAssets))}async#I(){await this.#v(),await this.#m()}#h(e){this.trace('Service Worker installing:',e),e.waitUntil(this.#I())}#d(e){const t=this;return t.trace('Service Worker activated:',e),t.#r?.preload&&e.waitUntil(t.#E()),self.clients.claim()}#f(e){const t=this;t.trace('Push message received:',e);const a=e.data?.json();let n=null;'NOTIFICATION'===a?.type&&(n=a?.data),'NOTIFICATION_WAITING'===a?.type&&(n=t.#l),n&&t.#y(t.#l)}#p(e){this.trace('Sync message received:',e)}#u(e){const t=this;t.#c.match(e.request)?(t.trace('Fetch event for:',e.request.url),e.respondWith(t.#o.cacheFirst(e.request,e))):t.trace('Fetch filter skip for:',e.request.url)}#N(e){this.#s&&(me.trace('Client message received on port:',e),e.target?.postMessage(`Hi client: ${e.data} from Service Worker Port2`))}#g(e){const t=this;if(!t.#A(e)){if(t.#R(e),'SKIP_WAITING'===e.data)return self.skipWaiting();'CLEAR_CACHE'!==e.data?'NOTIFICATION_WAITING'!==e.data?t.#F(e):e.waitUntil(t.#y(t.#l)):e.waitUntil(t.#o.clearCache())}}#w(e){this.#s('Message deserialization failed:',e)}async#C(e){'refresh'===e.action&&(this.trace('Notification action: Refresh'),self.registration?.waiting?.postMessage('SKIP_WAITING'))}#A(e){return e.source===self.serviceWorker}async#E(){self.registration.navigationPreload&&await self.registration.navigationPreload.enable()}#R(e){const t=this;'TRACE_ON'===e?.data?(t.#s=!0,console.warn('Service Worker trace enabled')):'TRACE_OFF'===e?.data&&(t.#s=!1,console.warn('Service Worker trace disabled')),t.#s&&(t.trace('Service Worker message received:',e),e.source?.postMessage(`Hi client: ${e.data} from Service Worker`))}#F(e){const t=this;if('INIT_PORT'===e?.data&&e?.ports[0])return t.trace('Client port init :',e),e.ports[0].onmessage=t.#N.bind(t),!0}async#y(e){if(this.trace('Notification received:',e),e)return self.registration.showNotification(e.title,e)}trace(e,t=''){this.#s&&console.trace(e,t)}static create(e){return new WorkerEngine(e)}}export{CacheEngine,FilterEngine,WorkerEngine};
//# sourceMappingURL=io.greenscreens.worker.min.js.map
