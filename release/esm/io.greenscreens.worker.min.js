var e=class{#e;constructor(e){if(!("caches"in self))throw Error("Cache API is not supported in this browser.");this.#e=e||"DefaultCache"}get name(){return this.#e}async init(){return caches.open(this.#e)}async addResourcesToCache(e){return(await this.init()).addAll(e)}async putInCache(e,t){return(await this.init()).put(e,t)}async getFromCache(e){return(await this.init()).match(e)}async #t(e,t,i){i?i.waitUntil(this.putInCache(e,t.clone())):await this.putInCache(e,t.clone())}async fetchAndCache(e,t){let i=await fetch(e);return i.ok&&await this.#t(e,i),i}async cacheFirst(e,t){let i=await this.getFromCache(e);if(i)return i;let s=await t?.preloadResponse;return s?(await this.#t(e,fetchedResponse),s):this.fetchAndCache(e,t)}async clearCache(){let e=await this.init();return e.keys().then(t=>Promise.all(t.map(t=>e.delete(t))))}},t=class{#i=new Map;#s=new Map;constructor(e,t){this.registerAll(e)}registerAll(e=[]){for(let t of e){if("string"!=typeof t.name){console.warn("Invalid filter format. Expected { name: string, fn: function }");continue}"string"==typeof t.rule&&(t.rule=new RegExp(t.rule)),t.fn?this.register(t.name,t.fn,t.ignore):t.rule instanceof RegExp&&this.register(t.name,this.#a(t),t.ignore)}}#a(e){let t=e.rule,i=!!e.parsed;return e=>(t.lastIndex=0,i?t.test(URL.parse(e.url).pathname.toLowerCase()):t.test(e.url.toLowerCase()))}register(e,t,i=!1){if(this.#i.has(e))return void console.warn(`Filter with name ${e} already exists.`);i?this.#s.set(e,t):this.#i.set(e,t)}unregister(e){if(!this.#i.has(e))return void console.warn(`Filter with name ${e} does not exist.`);this.#i.delete(e)}match(e){for(let t of this.#s.values())if(t(e))return!1;for(let t of this.#i.values())if(t(e))return!0;return!1}},i=class i{#r=!1;#n=null;#c=null;#o=null;#h={title:"Refresh now?",body:"New version of the app is available.",requireInteraction:!0,actions:[{action:"refresh",title:"Refresh"},{action:"cancel",title:"Cancel"}],data:{}};constructor(i){this.#n=i||{},this.#r=i?.trace||!1,this.#c=new t(i?.filters||[]),this.#o=new e(i?.cacheName||"DefaultCache"),self.addEventListener("install",this.#l.bind(this)),self.addEventListener("activate",this.#d.bind(this)),self.addEventListener("push",this.#f.bind(this)),self.addEventListener("sync",this.#p.bind(this)),self.addEventListener("fetch",this.#u.bind(this)),self.addEventListener("message",this.#g.bind(this)),self.addEventListener("messageerror",this.#w.bind(this)),self.addEventListener("notificationclick",this.#v.bind(this))}async #C(){if(this.#n?.preCacheURL){this.trace("Precached JSON definition:",this.#n?.preCacheURL);let e=await fetch(this.#n.preCacheURL);if(!e.ok)throw Error(`Failed to fetch precache URL: ${this.#n.preCacheURL}`);let t=await e.json();this.trace("Precached files:",t),await this.#o.addResourcesToCache(t)}}async #m(){this.#n?.precachedAssets&&(this.trace("Precached assets:",this.#n?.precachedAssets),await this.#o.addResourcesToCache(this.#n.precachedAssets))}async #I(){await this.#C(),await this.#m()}#l(e){this.trace("Service Worker installing:",e),e.waitUntil(this.#I())}#d(e){return this.trace("Service Worker activated:",e),this.#n?.preload&&e.waitUntil(this.#y()),self.clients.claim()}#f(e){this.trace("Push message received:",e);let t=e.data?.json(),i=null;t?.type==="NOTIFICATION"&&(i=t?.data),t?.type==="NOTIFICATION_WAITING"&&(i=this.#h),i&&this.#A(this.#h)}#p(e){this.trace("Sync message received:",e)}#u(e){this.#c.match(e.request)?(this.trace("Fetch event for:",e.request.url),e.respondWith(this.#o.cacheFirst(e.request,e))):this.trace("Fetch filter skip for:",e.request.url)}#E(e){this.#r&&(me.trace("Client message received on port:",e),e.target?.postMessage(`Hi client: ${e.data} from Service Worker Port2`))}#g(e){if(!this.#N(e)){if(this.#R(e),"SKIP_WAITING"===e.data)return self.skipWaiting();if("CLEAR_CACHE"===e.data)return void e.waitUntil(this.#o.clearCache());if("REFRESH_CACHE"===e.data)return void e.waitUntil(this.#C());if("NOTIFICATION_WAITING"===e.data)return void e.waitUntil(this.#A(this.#h));if(this.#F(e))return}}#w(e){this.#r("Message deserialization failed:",e)}async #v(e){"refresh"===e.action&&(this.trace("Notification action: Refresh"),self.registration?.waiting?.postMessage("SKIP_WAITING"))}#N(e){return e.source===self.serviceWorker}async #y(){self.registration.navigationPreload&&await self.registration.navigationPreload.enable()}#R(e){e?.data==="TRACE_ON"?(this.#r=!0,console.warn("Service Worker trace enabled")):e?.data==="TRACE_OFF"&&(this.#r=!1,console.warn("Service Worker trace disabled")),this.#r&&(this.trace("Service Worker message received:",e),e.source?.postMessage(`Hi client: ${e.data} from Service Worker`))}#F(e){if(e?.data==="INIT_PORT"&&e?.ports[0])return this.trace("Client port init :",e),e.ports[0].onmessage=this.#E.bind(this),!0}async #A(e){if(this.trace("Notification received:",e),e)return self.registration.showNotification(e.title,e)}trace(e,t=""){this.#r&&console.trace(e,t)}static create(e){return new i(e)}};export{e as CacheEngine,t as FilterEngine,i as WorkerEngine};
//# sourceMappingURL=io.greenscreens.worker.min.js.map