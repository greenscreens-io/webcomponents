class CacheEngine{#e;constructor(e){if(!('caches'in self))throw new Error('Cache API is not supported in this browser.');this.#e=e||'DefaultCache'}get name(){return this.#e}async init(){return caches.open(this.#e)}async addResourcesToCache(e){return(await this.init()).addAll(e)}async putInCache(e,t){return(await this.init()).put(e,t)}async getFromCache(e){return(await this.init()).match(e)}async fetchAndCache(e,t){const a=this,i=await fetch(e);return i.ok&&(t?t.waitUntil(a.putInCache(e,i.clone())):await a.putInCache(e,i.clone())),i}async cacheFirst(e,t){const a=this,i=await a.getFromCache(e);if(i)return i;const n=await(t?.preloadResponse);return n?(t.waitUntil(a.putInCache(e,n.clone())),n):a.fetchAndCache(e,t)}async clearCache(){const e=await this.init();return e.keys().then((t=>Promise.all(t.map((t=>e.delete(t))))))}}class FilterEngine{#t=new Map;constructor(e){this.registerAll(e)}registerAll(e=[]){const t=this;for(const a of e)'string'==typeof a.name&&('string'==typeof a.rule&&(a.rule=new RegExp(a.rule)),a.fn?t.register(a.name,a.fn):a.rule instanceof RegExp&&t.register(a.name,t.#a(a)))}#a(e){const t=e.rule,a=!!e.parsed;return e=>(t.lastIndex=0,a?t.test(URL.parse(e.url).pathname.toLowerCase()):t.test(e.url.toLowerCase()))}register(e,t){this.#t.has(e)||this.#t.set(e,t)}unregister(e){this.#t.has(e)&&this.#t.delete(e)}match(e){for(const[t,a]of this.#t.entries())if(a(e))return!0;return!1}}class WorkerEngine{#i=!1;#n=null;#s=null;#r=null;#c={title:'Refresh now?',body:'New version of the app is available.',requireInteraction:!0,actions:[{action:'refresh',title:'Refresh'},{action:'cancel',title:'Cancel'}],data:{}};constructor(e){const t=this;t.#n=e||{},t.#i=e?.trace||!1,t.#s=new FilterEngine(e?.filters||[]),t.#r=new CacheEngine(e?.cacheName||'DefaultCache'),self.addEventListener('install',t.#o.bind(t)),self.addEventListener('activate',t.#l.bind(t)),self.addEventListener('push',t.#h.bind(t)),self.addEventListener('sync',t.#d.bind(t)),self.addEventListener('fetch',t.#f.bind(t)),self.addEventListener('message',t.#p.bind(t)),self.addEventListener('messageerror',t.#u.bind(t)),self.addEventListener('notificationclick',t.#g.bind(t))}async#C(){const e=this;if(e.#n?.preCacheURL){e.trace('Precached JSON definition:',e.#n?.preCacheURL);const t=await fetch(e.#n.preCacheURL);if(!t.ok)throw new Error(`Failed to fetch precache URL: ${e.#n.preCacheURL}`);const a=await t.json();e.trace('Precached files:',a),await e.#r.addResourcesToCache(a)}}async#w(){const e=this;e.#n?.precachedAssets&&(e.trace('Precached assets:',e.#n?.precachedAssets),await e.#r.addResourcesToCache(e.#n.precachedAssets))}async#v(){await this.#C(),await this.#w()}#o(e){this.trace('Service Worker installing:',e),e.waitUntil(this.#v())}#l(e){const t=this;return t.trace('Service Worker activated:',e),t.#n?.preload&&e.waitUntil(t.#I()),self.clients.claim()}#h(e){const t=this;t.trace('Push message received:',e);const a=e.data?.json();let i=null;'NOTIFICATION'===a?.type&&(i=a?.data),'NOTIFICATION_WAITING'===a?.type&&(i=t.#c),i&&t.#m(t.#c)}#d(e){this.trace('Sync message received:',e)}#f(e){const t=this;t.#s.match(e.request)?(t.trace('Fetch event for:',e.request.url),e.respondWith(t.#r.cacheFirst(e.request,e))):t.trace('Fetch filter skip for:',e.request.url)}#E(e){this.#i&&(me.trace('Client message received on port:',e),e.target?.postMessage(`Hi client: ${e.data} from Service Worker Port2`))}#p(e){const t=this;if(!t.#N(e)){if(t.#A(e),'SKIP_WAITING'===e.data)return self.skipWaiting();'CLEAR_CACHE'!==e.data?'NOTIFICATION_WAITING'!==e.data?t.#y(e):e.waitUntil(t.#m(t.#c)):e.waitUntil(t.#r.clearCache())}}#u(e){this.#i('Message deserialization failed:',e)}async#g(e){'refresh'===e.action&&(this.trace('Notification action: Refresh'),self.registration?.waiting?.postMessage('SKIP_WAITING'))}#N(e){return e.source===self.serviceWorker}async#I(){self.registration.navigationPreload&&await self.registration.navigationPreload.enable()}#A(e){const t=this;'TRACE_ON'===e?.data?t.#i=!0:'TRACE_OFF'===e?.data&&(t.#i=!1),t.#i&&(t.trace('Service Worker message received:',e),e.source?.postMessage(`Hi client: ${e.data} from Service Worker`))}#y(e){const t=this;if('INIT_PORT'===e?.data&&e?.ports[0])return t.trace('Client port init :',e),e.ports[0].onmessage=t.#E.bind(t),!0}async#m(e){if(this.trace('Notification received:',e),e)return self.registration.showNotification(e.title,e)}trace(e,t=''){this.#i}static create(e){return new WorkerEngine(e)}}export{CacheEngine,FilterEngine,WorkerEngine};
//# sourceMappingURL=io.greenscreens.worker.min.js.map
