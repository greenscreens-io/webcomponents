{"version":3,"file":"io.greenscreens.worker.all.min.js","sources":["../../modules/worker/Cache.mjs","../../modules/worker/Filter.mjs","../../modules/worker/Worker.mjs"],"sourcesContent":["\r\n/**\r\n * CacheEngine class provides a simple interface to manage caching of resources using the Cache API.\r\n */\r\nexport class CacheEngine {\r\n\r\n  #name;\r\n  #cache;\r\n\r\n  /**\r\n   * Creates an instance of CacheEngine with a specified cache name.\r\n   * @param {*} name \r\n   */\r\n  constructor(name) {\r\n    this.#name = name || 'DefaultCache';\r\n  }\r\n\r\n  /**\r\n   * Returns the name of the cache.\r\n   */\r\n  get name() {\r\n    return this.#name;\r\n  }\r\n  \r\n  /**\r\n   * Returns true if the cache engine is initialized.\r\n   */\r\n  get isInitialized() {\r\n    return this.#cache ? true : false;\r\n  }\r\n\r\n  /**\r\n   * Initialize the cache engine.\r\n   * This should be called first before using the cahe engine.\r\n   * @returns \r\n   */\r\n  async init() {  \r\n    if (!('caches' in self)) {\r\n      console.warn('Cache API is not supported in this browser.');\r\n      return false;\r\n    }\r\n    this.#cache = await caches.open(this.#name);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Add resources to cache.\r\n   * @param {*} resources \r\n   * @returns \r\n   */\r\n  addResourcesToCache(resources) {\r\n    return this.#cache.addAll(resources);\r\n  }\r\n\r\n  /**\r\n   * Put the response in cache for the given request.\r\n   * @param {*} request \r\n   * @param {*} response \r\n   * @returns \r\n   */\r\n  putInCache(request, response) {\r\n    return this.#cache.put(request, response);\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache for the given request.\r\n   * @param {*} request \r\n   * @returns \r\n   */\r\n  getFromCache(request) {\r\n    return this.#cache.match(request);\r\n  }\r\n\r\n  /**\r\n   * Fetch resource from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @returns \r\n   */\r\n  async fetchAndCache(request) { \r\n    const me = this;\r\n    const fetchedResponse = await fetch(request);\r\n    if (fetchedResponse.ok) {\r\n      await me.putInCache(request, fetchedResponse.clone());\r\n    }\r\n    return fetchedResponse;\r\n  }\r\n\r\n  /**\r\n   * Get the response from cache first, if not found, \r\n   * fetch it from network and cache it before returning the result.\r\n   * @param {*} request \r\n   * @returns Promise<Response>\r\n   */\r\n  async cacheFirst(request) {\r\n    const me = this;\r\n    const responseFromCache = await me.getFromCache(request);\r\n    return responseFromCache || me.fetchAndCache(request);\r\n  }\r\n}","\r\nexport class FilterEngine {\r\n\r\n  #filters = new Map();\r\n\r\n  constructor(filters) {\r\n    this.registerAll(filters);\r\n  }\r\n\r\n  registerAll(filters = []) {\r\n    for (const filter of filters) {\r\n      if (typeof filter.name !== 'string' || typeof filter.fn !== 'function') {\r\n        console.warn('Invalid filter format. Expected { name: string, fn: function }');\r\n        continue;\r\n      }\r\n      this.register(filter.name, filter.fn);\r\n    }\r\n  }\r\n\r\n  register(name, filter) {\r\n    if (this.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} already exists.`);\r\n      return;\r\n    }\r\n    this.#filters.set(name, filter);\r\n  }\r\n\r\n  unregister(name) {\r\n    if (!this.#filters.has(name)) {\r\n      console.warn(`Filter with name ${name} does not exist.`);\r\n      return;\r\n    }\r\n    this.#filters.delete(name);\r\n  }\r\n\r\n  match(request) {\r\n    for (const [name, filter] of this.#filters.entries()) {\r\n      if (filter(request)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}","\r\nimport { FilterEngine } from \"./Filter.mjs\";\r\nimport { CacheEngine } from \"./Cache.mjs\";\r\n\r\nexport class WorkerEngine {\r\n\r\n  #trace = false;\r\n  #options = null;\r\n  #filter = null;\r\n  #cache = null;\r\n\r\n  constructor(options) {\r\n    const me = this;\r\n    me.#options = options || {};\r\n    me.#trace = options?.trace || false;\r\n    me.#filter = new FilterEngine(options?.filters || []);\r\n    me.#cache = new CacheEngine(options?.cacheName || 'DefaultCache');\r\n  }\r\n\r\n  async start() {\r\n    const me = this;\r\n    await me.#cache.init();\r\n    if (!me.#cache.isInitialized) {\r\n      console.warn('Cache initialization failed. Service Worker will not start.');\r\n      return;\r\n    }\r\n    self.addEventListener('install', me.#onInstall.bind(me));\r\n    self.addEventListener('activate', me.#onActivate.bind(me));\r\n    self.addEventListener('push', me.#onPush.bind(me));\r\n    self.addEventListener('sync', me.#onSync.bind(me));\r\n    self.addEventListener('fetch', me.#onFetch.bind(me));\r\n    self.addEventListener('message', me.#onMessage.bind(me));\r\n  }\r\n\r\n  #onInstall(event) {\r\n    const me = this;\r\n    if (me.#trace) {\r\n      console.log('Service Worker installing:', event);\r\n    }\r\n    if (me.#options?.precachedAssets) {\r\n      event.waitUntil(\r\n        me.#cache.addResourcesToCache(me.#options.precachedAssets)\r\n      );\r\n    }\r\n  }\r\n\r\n  #onActivate(event) {\r\n    if (this.#trace) {\r\n      console.log('Service Worker activated:', event);\r\n    }\r\n    return self.clients.claim();\r\n  }\r\n\r\n  #onPush(event) {\r\n    if (this.#trace) {\r\n      console.log('Push message received:', event);\r\n    }\r\n  }\r\n\r\n  #onSync(event) {\r\n    if (this.#trace) {\r\n      console.log('Sync message received:', event);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Intercept fetch events and respond with cached resources if they match the filter.\r\n   * @param {*} event \r\n   * @returns \r\n   */\r\n  #onFetch(event) {\r\n    const me = this;\r\n\r\n    if (me.#trace) {\r\n      console.log('Fetch event for:', event.request.url);\r\n    }\r\n\r\n    // Check if the request matches any filter\r\n    if (!me.#filter.match(event.request)) return;\r\n\r\n    event.respondWith(\r\n      me.#cache.cacheFirst(event.request)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients based on message channel.\r\n   * @param {*} event \r\n   */\r\n  #onPortMessage(event) {\r\n    if (this.#trace) {\r\n      console.log('Client message received on port:', event);\r\n      event.target?.postMessage(`Hi client: ${event.data} from Service Worker Port2`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle messages from clients or other sources.\r\n   * This method is called when a message is received by the service worker.\r\n   * @param {MessageEvent} event \r\n   */\r\n  #onMessage(event) {\r\n    const me = this;\r\n    if (me.#isSelf(event)) return;\r\n\r\n    me.#handleTrace(event);\r\n    if (event.data === 'SKIP_WAITING') {\r\n      return self.skipWaiting();\r\n    }\r\n\r\n    if (me.#handleChannel(event)) return;\r\n\r\n    // TODO: Handle other message types\r\n\r\n  }\r\n\r\n  // Check if the event source is the service worker itself\r\n  #isSelf(event) {\r\n    return event.source === self.serviceWorker;\r\n  }\r\n\r\n  #handleTrace(event) {\r\n    const me = this;\r\n    if (event.data === 'TRACE_ON') {\r\n      me.#trace = true;\r\n      console.log('Service Worker trace enabled');\r\n    } else if (event.data === 'TRACE_OFF') {\r\n      me.#trace = false;\r\n      console.log('Service Worker trace disabled');\r\n    }\r\n\r\n    if (me.#trace) {\r\n      console.log('Service Worker message received:', event);\r\n      event.source?.postMessage(`Hi client: ${event.data} from Service Worker`);\r\n    }\r\n  }\r\n\r\n  #handleChannel(event) {\r\n    const me = this;\r\n    if (event.data === 'INIT_PORT' && event.ports[0]) {\r\n      if (me.#trace) {\r\n        console.log('Client port init :', event);\r\n      }\r\n      event.ports[0].onmessage = me.#onPortMessage.bind(me);\r\n      return true;\r\n    }\r\n  }\r\n}"],"names":["CacheEngine","name","cache","constructor","this","isInitialized","async","self","caches","open","addResourcesToCache","resources","addAll","putInCache","request","response","put","getFromCache","match","me","fetchedResponse","fetch","ok","clone","fetchAndCache","FilterEngine","filters","Map","registerAll","filter","fn","register","has","set","unregister","delete","entries","WorkerEngine","trace","options","cacheName","init","addEventListener","onInstall","bind","onActivate","onPush","onSync","onFetch","onMessage","event","precachedAssets","waitUntil","clients","claim","respondWith","cacheFirst","onPortMessage","target","postMessage","data","isSelf","handleTrace","skipWaiting","handleChannel","source","serviceWorker","ports","onmessage"],"mappings":"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"}